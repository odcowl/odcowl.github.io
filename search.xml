<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1035.不相交的线(Medium)</title>
    <url>/2021/05/21/1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF-Medium/</url>
    <content><![CDATA[<p>LeetCodee每日一题(2021.05.21)之<a href="https://leetcode-cn.com/problems/uncrossed-lines/">不相交的线</a><br>难度：中等</p>
<h3 id="题目">0.0.1. 题目</h3><p>在两条独立的水平线上按给定的顺序写下<code>nums1</code>和<code>nums2</code>中的整数。</p>
<p>现在，可以绘制一些连接两个数字<code>nums1[i]</code>和<code>nums2[j]</code>的直线，这些直线需要同时满足满足：</p>
<p><code>nums1[i] == nums2[j]</code><br>且绘制的直线不与任何其他连线（非水平线）相交。<br>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例1</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/28/142.png" alt="img1"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,4,2], nums2 = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</span><br></pre></td></tr></table></figure>
<p><strong>示例2</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure></p>
<p><strong>示例3</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure></p>
<p>提示：</p>
<p>1 &lt;= nums1.length &lt;= 500<br>1 &lt;= nums2.length &lt;= 500<br>1 &lt;= nums1[i], nums2[i] &lt;= 2000</p>
<h3 id="暂时错误的思路">0.0.2. 暂时错误的思路</h3><p>一开始看到这道题，我想到的是数学中如何验证平面上两条线段是否相交，也就是讲问题转化成了：给定两个线段的坐标（也就是四个点的直角坐标系坐标），判断这两个线段是否相交。</p>
<p>假定输入p1,p2,q1,q2四个点的坐标，p1p2为一条线段,q1q2为另外一条线段。</p>
<p>两条线段相交只有两种情况：</p>
<ol>
<li>其中一条线段的某一端点在另一条线段上</li>
<li>两条线段成X型</li>
</ol>
<p>详细的解题过程见：<a href="https://c.lanmit.com/bianchengkaifa/Python/15518.html">参考</a></p>
<p>实际上没有用上的代码部分:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def judge(a,b,c,d):</span><br><span class="line">            <span class="keyword">if</span> min(a[0],b[0])&lt;=max(c[0],d[0]) and min(c[1],d[1])&lt;=max(a[1],b[1]) and min(c[0],d[0])&lt;=max(a[0],b[0]) and min(a[1],b[1])&lt;=max(c[1],d[1]):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">0.0.3. 解题思路</h3><p>这道题LC解题思路里给出的基本为动态规划的解法，也是我算法里最差的一部分。</p>
<p><strong>定义</strong></p>
<ul>
<li><code>dp[i][j]</code>表示数组nums1的前<code>i</code>个数字和数组nums2的前<code>j</code>个数字能形成的不相交的线的最大数。（大问题化小问题）</li>
<li>其中<code>m</code>为nums1长度，<code>n</code>为nums2长度</li>
</ul>
<p><strong>重点：状态转移方程</strong></p>
<ul>
<li>对于任意 0 &lt; j &lt; m, 0 &lt; j &lt; n, 当<code>nums1[i]</code>和nums2[j]`数字相同的时候：<ul>
<li>当前最大连线数又可以增加一条，用<code>dp[i-1][j-1]+1</code>表示</li>
</ul>
</li>
<li>如果数字不相同，可以从nums1或nums2去掉一个数字进行比较<ul>
<li>比如比较 dp[i-1][j]dp[i−1][j] 和 dp[i][j-1]dp[i][j−1], 取两者中的较大值来更新 dp[i][j]dp[i][j] 即可.</li>
<li>dp[i-1][j]dp[i−1][j] 代表不考虑 nums[i]nums[i] 字符, nums[j]nums[j] 是考虑的, 但不是必须包含. dp[i][j-1]dp[i][j−1] 同理</li>
</ul>
</li>
<li>最后，遍历完成后，结果在dp[m][n]上</li>
</ul>
<p>实现代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxUncrossedLines(self, nums1, nums2):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        m, n = len(nums1),len(nums2)</span><br><span class="line"></span><br><span class="line">        dp = [[0 <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+1)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+1)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(1,m+1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(1,n+1):</span><br><span class="line">                dp[i][j] = max(dp[i-1][j],dp[i][j-1])</span><br><span class="line">                <span class="keyword">if</span> nums1[i-1] == nums2[j-1]:</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></p>
<p><a href="https://leetcode-cn.com/problems/uncrossed-lines/solution/chi-xiao-dou-python-tu-wen-jian-ming-si-s7ukn/">赤小豆</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>1047.删除字符串中的所有相邻重复项(Easy)</title>
    <url>/2021/03/09/1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9-Easy/</url>
    <content><![CDATA[<p>LeetCode每日一题(2021.03.09)之<a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a><br>难度：简单</p>
<h3 id="一、题目">0.0.1. 一、题目</h3><p>给出由小写字母组成的字符串<code>s</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在<code>s</code>上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符。答案保持唯一。</p>
<p>示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;abbaca&quot;</span></span><br><span class="line">输出：<span class="string">&quot;ca&quot;</span></span><br><span class="line">解释：</span><br><span class="line">例如，在 <span class="string">&quot;abbaca&quot;</span> 中，我们可以删除 <span class="string">&quot;bb&quot;</span> 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 <span class="string">&quot;aaca&quot;</span>，其中又只有 <span class="string">&quot;aa&quot;</span> 可以执行重复项删除操作，所以最后的字符串为 <span class="string">&quot;ca&quot;</span>。</span><br></pre></td></tr></table></figure></p>
<p>提示：</p>
<ol>
<li>1 &lt;= S.length &lt;= 20000</li>
<li>S 仅由小写英文字母组成。</li>
</ol>
<h3 id="二、我的解法">0.0.2. 二、我的解法</h3><p><strong>思路</strong>：</p>
<ul>
<li>如从字符串abba中先删除bb，会有新的重复字符串aa出现，所以需要保存当前还未被删除的字符串，联想到<code>栈</code>这种数据结构</li>
<li>当字符串中有多组相邻重复项时，先删除哪一组不影响结果</li>
</ul>
<p><code>296ms, 11.52%; 13.4MB, 73.03%</code><br>我的小菜鸡伪栈法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def removeDuplicates(self, S):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        res = <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> char != res[-1]:</span><br><span class="line">                res += char</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = res[:-1]</span><br><span class="line">        <span class="built_in">return</span> res[1:]</span><br></pre></td></tr></table></figure></p>
<h3 id="三、其他的解法">0.0.3. 三、其他的解法</h3><h4 id="3-1-栈">0.0.3.1. 3.1 栈</h4><p>感觉想法差不多，官方的栈效率高多了：<br><code>52ms, 88.07%; 13.4MB, 81.74%</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, S: str) -&gt; str:</span><br><span class="line">        stk = list()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> stk and stk[-1] == ch:</span><br><span class="line">                stk.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append(ch)</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;&quot;</span>.join(stk)</span><br></pre></td></tr></table></figure>
<p>今天是个简单题，yeah</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>1052.爱生气的书店老板(Medium)</title>
    <url>/2021/02/26/1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF-Medium/</url>
    <content><![CDATA[<p>力扣每日一题系列(2021.02.23)之<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">爱生气的书店老板</a><br>难度：中等</p>
<h3 id="一、题目">0.0.1. 一、题目</h3><p>今天，书店老板有一家店打算试营业<code>customers.length</code>分钟。每分钟都有一些顾客<code>customers[i]</code>会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第<code>i</code>分钟生气，那么<code>grumpy[i] = 1</code>，否则<code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续<code>X</code>分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p>
<h4 id="示例">0.0.1.1. 示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.</span><br></pre></td></tr></table></figure>
<h4 id="提示">0.0.1.2. 提示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; X &lt;&#x3D; customers.length &#x3D;&#x3D; grumpy.length &lt;&#x3D; 20000</span><br><span class="line">0 &lt;&#x3D; customers[i] &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; grumpy[i] &lt;&#x3D; 1</span><br></pre></td></tr></table></figure>
<h3 id="二、我的解法">0.0.2. 二、我的解法</h3><p>我的第一个想法是利用暴力解法。（渣</p>
<p>通过按顺序替换<code>grumpy</code>里不生气的日期，再把每个新的<code>grumpy</code>和<code>customers</code>点乘求和，保存满意客户的最大数量。注意，<code>grumpy</code>和<code>customers</code>点乘前，需要注意把<code>0（不生气）</code>替换成<code>1</code>，把<code>1（生气）</code>替换成<code>0</code>，这样才能使用点乘。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSatisfied(self, customers, grumpy, X):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type customers: List[int]</span></span><br><span class="line"><span class="string">        :type grumpy: List[int]</span></span><br><span class="line"><span class="string">        :type X: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">#滑动窗口</span></span><br><span class="line">        res = 0</span><br><span class="line">        <span class="comment">#先将grumpy里的1和0替换，方便后面点乘</span></span><br><span class="line">        <span class="comment">#1:不生气，服务客户 0:生气，去你娘滴</span></span><br><span class="line">        grumpy = [1-i <span class="keyword">for</span> i <span class="keyword">in</span> grumpy]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grumpy)-X+1):</span><br><span class="line">            grumpy_now = grumpy[:i] + [1]*X + grumpy[i+X:]</span><br><span class="line">            <span class="comment">#satis：满意度列表</span></span><br><span class="line">            satis = map(lambda x,y:x*y, grumpy_now, customers)</span><br><span class="line">            <span class="comment">#保留最大res</span></span><br><span class="line">            res = max(res,sum(satis))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure><br>但是这个解法只ac了<code>73/38</code>，查看发现是那种非常长的列表无法通过。</p>
<h3 id="滑动窗口算法">0.0.3. 滑动窗口算法</h3><p>引用思路来自: <a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/yong-mi-mi-ji-qiao-wan-liu-zhu-zui-duo-d-py41/">负雪明烛</a></p>
<p>依然是<code>滑动窗口</code>的思路。</p>
<h4 id="1-解题思路">0.0.3.1. 1.解题思路</h4><ul>
<li>将题目分为两部分，第一部分是不做出任何改变会留下的顾客origin，第二部分是每一个<code>不生气窗口X</code>的可以留下的本被赶走的客户数increse。</li>
<li>得到的客户总数就是 origin + max(increse)</li>
</ul>
<p>按照这个思路，我又自己写了一遍代码，<code>ac100%</code>了但是执行用时5.06%…<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSatisfied(self, customers, grumpy, X):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type customers: List[int]</span><br><span class="line">        :type grumpy: List[int]</span><br><span class="line">        :type X: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        #滑动窗口</span><br><span class="line">        increase &#x3D; 0</span><br><span class="line">        origin &#x3D; sum(map(lambda x,y:x*y, [1-i for i in grumpy], customers))</span><br><span class="line">        </span><br><span class="line">        for i in range(len(grumpy)-X+1):</span><br><span class="line">            grumpy_now, customers_now &#x3D; grumpy[i:i+X],customers[i:i+X]</span><br><span class="line">            satis &#x3D; 0</span><br><span class="line">            for j in range(len(grumpy_now)):</span><br><span class="line">                if grumpy_now[j] &#x3D;&#x3D; 1:</span><br><span class="line">                    satis +&#x3D; customers_now[j]</span><br><span class="line">            increase &#x3D; max(increase,satis)</span><br><span class="line">        return origin + increase</span><br></pre></td></tr></table></figure><br>所以接下来是我学习上方参考链接的做题方法写的<code>ac100%</code>，248ms(82.24%), 15MB(47.72%)<br>总体分为：</p>
<ol>
<li>算毫无作为时满意的客户数量 origin</li>
<li>算滑动窗口X带来的改变 通过curValue的最大值resValue</li>
</ol>
<ul>
<li>算前X个格子</li>
<li>算第X到len(grumpy)个格子</li>
</ul>
<ol>
<li>得到结果为origin+resValue<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSatisfied(self, customers, grumpy, X):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type customers: List[int]</span><br><span class="line">        :type grumpy: List[int]</span><br><span class="line">        :type X: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        </span><br><span class="line">        #第一步: 计算不做任何改变，满意客户的数量</span><br><span class="line">        origin &#x3D; sum(map(lambda x,y:x*y, [1-i for i in grumpy], customers))</span><br><span class="line">        </span><br><span class="line">        #第二步：计算滑动窗口里可以增加满意客户的数量</span><br><span class="line">        # 2.1 先计算前X个格子的值</span><br><span class="line">        curValue &#x3D; 0</span><br><span class="line">        for i in range(X):</span><br><span class="line">            if grumpy[i] &#x3D;&#x3D; 1:</span><br><span class="line">                curValue +&#x3D; customers[i]</span><br><span class="line">        resValue &#x3D; curValue</span><br><span class="line">        # 2.2 开始向右滑————————————</span><br><span class="line">        for i in range(X,len(grumpy)):</span><br><span class="line">            #先验证左边（左边滑出的那个格子）是否在生气，如果在生气，需要在curValue剪掉</span><br><span class="line">            if grumpy[i-X] &#x3D;&#x3D; 1:</span><br><span class="line">                curValue -&#x3D; customers[i-X]</span><br><span class="line">            #再验证右边（右边新增的那个格子）是否在生气，如果在生气，需要在curValue加上</span><br><span class="line">            if grumpy[i] &#x3D;&#x3D; 1:</span><br><span class="line">                curValue +&#x3D; customers[i]</span><br><span class="line">            #判断当下curValue和史上最大curValue的关系</span><br><span class="line">            resValue &#x3D; max(resValue,curValue)</span><br><span class="line">        </span><br><span class="line">        return origin + resValue</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>1239.串联字符串的最大长度</title>
    <url>/2021/06/18/1239-%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>LeetCode每日一题之<a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">串联字符串的最大长度</a>.<br>难度：中等</p>
<h3 id="题目">0.0.1. 题目</h3><p>给定一个字符串数组<code>arr</code>，字符串<code>s</code>是将<code>arr</code>某一子序列字符串连接所得的字符串，如果<code>s</code>中的每一个字符都只出现过一次，那么它就是一个可行解。</p>
<p>请返回所有可行解<code>s</code>中最长长度。</p>
<p>示例 1：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="string">&quot;un&quot;</span>,<span class="string">&quot;iq&quot;</span>,<span class="string">&quot;ue&quot;</span>]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的串联组合是 <span class="string">&quot;&quot;</span>,<span class="string">&quot;un&quot;</span>,<span class="string">&quot;iq&quot;</span>,<span class="string">&quot;ue&quot;</span>,<span class="string">&quot;uniq&quot;</span> 和 <span class="string">&quot;ique&quot;</span>，最大长度为 4。</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="string">&quot;cha&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;act&quot;</span>,<span class="string">&quot;ers&quot;</span>]</span><br><span class="line">输出：6</span><br><span class="line">解释：可能的解答有 <span class="string">&quot;chaers&quot;</span> 和 <span class="string">&quot;acters&quot;</span>。</span><br></pre></td></tr></table></figure></p>
<p>示例 3：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [&quot;abcdefghijklmnopqrstuvwxyz&quot;]</span><br><span class="line">输出：26</span><br></pre></td></tr></table></figure></p>
<p>提示：</p>
<p>1 &lt;= arr.length &lt;= 16<br>1 &lt;= arr[i].length &lt;= 26<br>arr[i] 中只含有小写英文字母</p>
<h3 id="我的解法-79-85">0.0.2. 我的解法(79/85)</h3><p>很遗憾。。。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxLength(self, arr):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type arr: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not arr:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">        <span class="keyword">if</span> len(arr) == 1:</span><br><span class="line">            <span class="built_in">return</span> len(arr[0])</span><br><span class="line"></span><br><span class="line">        n = len(arr)</span><br><span class="line">        max_ = 0</span><br><span class="line">        act = <span class="string">&quot;&quot;</span></span><br><span class="line">        def isAppeared(str1,str2):</span><br><span class="line">            <span class="keyword">if</span> len(str1) &gt; len(str2):</span><br><span class="line">                str1, str2 = str2, str1</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> str1:</span><br><span class="line">                <span class="keyword">if</span> ch <span class="keyword">in</span> str2:</span><br><span class="line">                    <span class="built_in">return</span> True</span><br><span class="line">            <span class="built_in">return</span> False</span><br><span class="line">        def isPure(str1):</span><br><span class="line">            <span class="keyword">if</span> len(str1) == len(<span class="built_in">set</span>(str1)):</span><br><span class="line">                <span class="built_in">return</span> True</span><br><span class="line">            <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> isPure(arr[i]):</span><br><span class="line">                max_ = max(max_,len(arr[i]))</span><br><span class="line">                act = arr[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+1,n):</span><br><span class="line">                <span class="keyword">if</span> not isAppeared(act,arr[j]) and isPure(arr[j]):</span><br><span class="line">                    act = act + arr[j]</span><br><span class="line">                    max_ = max(max_,len(act))</span><br><span class="line">        <span class="built_in">return</span> max_</span><br></pre></td></tr></table></figure>
<h3 id="好的解法">0.0.3. 好的解法</h3><p>参考:<a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/python-zhi-bai-po-su-de-01bei-bao-by-qub-8441/">benhao</a></p>
<h4 id="直白质朴法">0.0.3.1. 直白质朴法</h4><p>我的思路总体和这个是一致的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxLength(self, arr: List[str]) -&gt; int:</span><br><span class="line">        def validStr(string):</span><br><span class="line">            <span class="built_in">return</span> len(<span class="built_in">set</span>(string)) == len(string)</span><br><span class="line">        </span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> not validStr(s):</span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">            <span class="keyword">for</span> s_ <span class="keyword">in</span> dp:</span><br><span class="line">                <span class="keyword">if</span> validStr(s_ + s):</span><br><span class="line">                    dp.append(s_ + s)</span><br><span class="line">            dp.append(s)</span><br><span class="line">        <span class="built_in">return</span> len(max(dp,key=len)) <span class="keyword">if</span> dp <span class="keyword">else</span> 0</span><br></pre></td></tr></table></figure></p>
<h3 id>0.0.4.  </h3><h3 id="回溯法">0.0.5. 回溯法</h3><p><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/hui-su-di-gui-shi-xian-wu-you-hua-by-nan-feng-14/">NoBug</a></p>
<p>回溯算法，采用递归实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution():</span><br><span class="line">    def maxLength(self, arr):</span><br><span class="line"></span><br><span class="line">        t &#x3D; []</span><br><span class="line">        for s in arr:</span><br><span class="line">            if len(set(s)) &#x3D;&#x3D; len(s):</span><br><span class="line">                t.append(s)</span><br><span class="line">        arr &#x3D; t[:]</span><br><span class="line"></span><br><span class="line">        def dfs(i, tmp):</span><br><span class="line"></span><br><span class="line">            if i &gt;&#x3D; len(arr):</span><br><span class="line">                return len(tmp)</span><br><span class="line">            else:</span><br><span class="line">                if not (set(tmp) &amp; set(arr[i])):</span><br><span class="line">                    return max(dfs(i+1,tmp+arr[i]),dfs(i+1,tmp))</span><br><span class="line">                else:</span><br><span class="line">                    return dfs(i + 1, tmp)</span><br><span class="line"></span><br><span class="line">        l&#x3D;dfs(0,&#39;&#39;)</span><br><span class="line">        return l</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>15.三数之和(Medium)</title>
    <url>/2021/02/26/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-Medium/</url>
    <content><![CDATA[<h3 id="题目描述">0.0.1. 题目描述</h3><p>给你一个包含<code>n</code>个整数的数组<code>nums</code>,判断<code>nums</code>中是否存在三个元素a,b,c，使得<code>a+b+c=0</code> ？请你找出所有和为<code>0</code>且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
<p>示例1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><br>示例2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><br>示例3:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><br>提示：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 0 &lt;= nums.length &lt;= 3000</span><br><span class="line">* -10^5 &lt;= nums[i] &lt;= 10^5</span><br></pre></td></tr></table></figure></p>
<h3 id="排序➕双指针解法">0.0.2. 排序➕双指针解法</h3><p>三数之和这道题我一直思路不清晰，下面的代码也只是复现别人的思路，接下来总结一下：</p>
<ol>
<li>边界条件判断，当<code>nums</code>不存在，或<code>len(nums)&lt;3</code>的时候，返回空集合<code>[]</code></li>
<li>对数组进行从小到大的排序</li>
<li>对排序后的数组开始遍历<ol>
<li>如果<code>nums[i]&gt;0</code>,由于数组已经排序过了，那么<code>nums[i]</code>后面的<code>nums[L]</code>和<code>nums[R]</code>肯定比<code>nums[i]</code>更大，三个大于零的数字和不等于零。</li>
<li>如果<code>nums[i]</code>和<code>nums[i-1]</code>是重复的，跳过</li>
<li>令左指针指向<code>L = i + 1</code>, 令右指针指向<code>R = len(nums)-1</code>（其实这就是最后一位)<ul>
<li>如果<code>nums[i]+nums[L]+nums[R]=0</code>，在答案列表里储存此组数；同时，判断<code>nums[L+1]</code>和<code>nums[L]</code>是否重复，及<code>nums[R]</code>和<code>nums[R-1]</code>是否重复，如果是的话，将<code>L，R</code>移到不再重复的位置，然后再令<code>L=L+1</code>,<code>R=R-1</code>即继续循环</li>
<li>如果<code>nums[i]+nums[L]+nums[R]&gt;0</code>, 说明右指针太大，<code>R</code>向左移动一位, <code>R=R-1</code></li>
<li>如果<code>nums[i]+nums[L]+nums[R]&lt;0</code>，说明左指针太小，<code>L</code>向右移动一位，<code>L=L+1</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 第一步：如果nums不存在或nums不到三个元素，返回空集</span></span><br><span class="line">        <span class="keyword">if</span> not nums or len(nums) &lt; 3:</span><br><span class="line">            <span class="built_in">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二步：对nums从小到大进行排序</span></span><br><span class="line">        nums.sort() </span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 第三步：对排序后的nums进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; 0:</span><br><span class="line">                <span class="built_in">return</span>  res <span class="comment">#如果nums[i]已经大于0，因为已排序，后面不可能再有数字和nums[i]相加并等于0，返回当下答案</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; 0 and nums[i] == nums[i-1]:</span><br><span class="line">                <span class="built_in">continue</span> <span class="comment">#如果nums[i]和nums[i-1]</span></span><br><span class="line">            L = i + 1 <span class="comment">#当下nums[i]的右边一位</span></span><br><span class="line">            R = len(nums) - 1 <span class="comment">#最后一位</span></span><br><span class="line">            <span class="keyword">while</span> L &lt; R: </span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[L]+nums[R] == 0:</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R and nums[L] == nums[L+1]:</span><br><span class="line">                        <span class="comment">#如果有重复的情况，自动移到重复最右端</span></span><br><span class="line">                        L = L + 1</span><br><span class="line">                    <span class="keyword">while</span> L &lt; R and nums[R] == nums[R-1]:</span><br><span class="line">                        <span class="comment">#如果有重复的情况，自动移到重复的最左端</span></span><br><span class="line">                        R = R - 1</span><br><span class="line">                    L = L + 1</span><br><span class="line">                    R = R - 1</span><br><span class="line">                <span class="comment">#如果和大于0，说明nums[R]太大，nums[R]向左移</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[L]+nums[R] &gt; 0:</span><br><span class="line">                    R = R - 1</span><br><span class="line">                <span class="comment">#如果和小于0，说明nums[L]太小，nums[L]向右移</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L = L + 1</span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>131.分割回文串(Medium)</title>
    <url>/2021/03/08/131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-Medium/</url>
    <content><![CDATA[<p>力扣每日一题系列(2021.03.07)之<a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a><br>难度:中等</p>
<h3 id="一、题目">0.0.1. 一、题目</h3><p>给你一个字符串<code>s</code>,请你将<code>s</code>分割成一些子串,使每个子串都是回文串.返回<code>s</code>所有可能的分割方案.<br><strong>回文串</strong>是正着读和反着读都一样的字符串.</p>
<p>示例1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: s=<span class="string">&quot;aab&quot;</span></span><br><span class="line">输出: [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>],[<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br></pre></td></tr></table></figure></p>
<p>示例2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出: [[<span class="string">&quot;a&quot;</span>]]</span><br></pre></td></tr></table></figure></p>
<p>提示:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 16</span><br><span class="line">s 仅由小写英文字母组成</span><br></pre></td></tr></table></figure></p>
<h3 id="二、题解">0.0.2. 二、题解</h3><p>代码思路学习:<a href="https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-fa-si-lu-yu-mo-ban-by-fuxuemingzh-azhz/">负雪明烛</a></p>
<p>题目要求返回<code>所有可能的结果</code>, 那么只能<strong>暴力搜索所有可能的解</strong>,在这种情况下可以联想到使用<code>回溯法</code>.回溯法(算法思想)可以用递归(编程方法)来实现.</p>
<h4 id="回溯法">0.0.2.1. 回溯法</h4><p><code>回溯法</code>实际上是一个类似<code>枚举</code>的搜索尝试过程.<br>对当前搜索路径下的未探索区域进行搜索,则可能有两种情况:</p>
<ol>
<li>当前未搜索区域满足条件,则保存当前路径并退出当前搜索</li>
<li>当前为搜索区域需要继续搜索,则遍历当前所有可能的选择,如果其中有选择符合要求,则把这个选择加入当前搜索路径中(递归),并继续搜索未搜索的路径</li>
</ol>
<p>负雪明烛版本的回溯法套用模版:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line">path = []</span><br><span class="line"></span><br><span class="line">def backtrack(未探索区域, res, path):</span><br><span class="line">    <span class="keyword">if</span> 未探索区域满足结束条件:</span><br><span class="line">        res.add(path) <span class="comment"># 深度拷贝</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 未探索区域当前可能的选择:</span><br><span class="line">        <span class="keyword">if</span> 当前选择符合要求:</span><br><span class="line">            path.add(当前选择)</span><br><span class="line">            backtrack(新的未探索区域, res, path)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>其中:<br><code>backtrack</code>表示: 未搜索区域中满足条件的所有可能路径<br><code>path</code>表示: 一条路径<br><code>res</code>表示: 搜索到满足的路径(将合格的path储存到res里)<br><code>path.pop()</code>表示: 在储存一个合格路径path后,需要将其清空,以免阻碍其他搜索</p>
<p><strong>本题图解</strong><br> <img src="/2021/03/08/131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-Medium/IMG_0847.jpg" class title="This is an example image"></p>
<h3 id="三、代码">0.0.3. 三、代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def partition(self, s):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        path = []</span><br><span class="line">        self.backtrack(s,res,path)</span><br><span class="line">        <span class="built_in">return</span> res</span><br><span class="line">        </span><br><span class="line">    def backtrack(self,s,res,path):</span><br><span class="line">        <span class="comment">#指针越界,res保存这个合格的path</span></span><br><span class="line">        <span class="keyword">if</span> not s:</span><br><span class="line">            res.append(path)  </span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(1,len(s)+1): <span class="comment">#i=1,2,3</span></span><br><span class="line">            <span class="comment">#如果当下切分满足回文串的条件</span></span><br><span class="line">            <span class="keyword">if</span> self.isSubstring(s[:i]):</span><br><span class="line">                <span class="comment">#递归:考虑剩余部分的切分方法</span></span><br><span class="line">                self.backtrack(s[i:], res, path + [s[:i]])</span><br><span class="line">                </span><br><span class="line">    def isSubstring(self, s):</span><br><span class="line">        <span class="keyword">if</span> s == s[::-1]:</span><br><span class="line">            <span class="built_in">return</span> True</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>224.基本计算器(Hard)</title>
    <url>/2021/03/09/224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-Hard/</url>
    <content><![CDATA[<p>每日一题系列(2021.03.10)之<a href="https://leetcode-cn.com/problems/basic-calculator/">基本计算器</a><br>难度：困难</p>
<h3 id="一、题目">0.0.1. 一、题目</h3><p>实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。</p>
<p>示例1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;1 + 1&quot;</span></span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure></p>
<p>示例2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot; 2-1 + 2 &quot;</span></span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure></p>
<p>示例3:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(1+(4+5+2)-3)+(6+8)&quot;</span></span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure></p>
<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 3 * 10^5</li>
<li>s 由数字、+、-、(、)、和   组成</li>
<li>s 表示一个有效的表达式</li>
</ul>
<h3 id="二、我的解法（误">0.0.2. 二、我的解法（误</h3><p>我看到这一题第一反应是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">return</span> <span class="built_in">eval</span>(s)</span><br></pre></td></tr></table></figure><br>完事走人（抓回来</p>
<p>想必LeetCode早就预见了我等无耻之人，于是乎，eval作废，我的脑子也废了，现在开始学习大神的解法。。。</p>
<p>ps：我总感觉这题在hw的题库里好像见过也做过，但是咋一点儿印象也米有了</p>
<h3 id="三、真正的解法">0.0.3. 三、真正的解法</h3><p>这道题里有加减号，也有括号，分三部来考虑这个问题：</p>
<ul>
<li>不考虑括号，只考虑数字、加减号和空格</li>
<li>考虑括号，数字，加减号和空格</li>
<li>考虑括号，数字，加减乘除号和空格</li>
</ul>
<p>以下部分参考了<a href="https://leetcode-cn.com/problems/basic-calculator/solution/zhan-by-powcai-3/">powcai</a>的做法</p>
<h4 id="不考虑括号，考虑加减号">0.0.3.1. 不考虑括号，考虑加减号</h4><p>在不考虑括号的情况时，不需要用到<code>栈</code>的思路，在顺序上也没有强行要求，要注意的一点是，看到加号或减号时，要同时考虑符号前一位的数字，和符号后一位的数字。所以用一个<code>sign</code>来记录。</p>
<p>在下面的代码中，只有当进入<code>elif s[i].isdigit():</code>这个格子里的时候，才有真正对res进行计算的操作:<code>res+= tmp * sign</code>。这里就迎来了第二个要注意的点，有时候数字并非只是个位数。</p>
<p>以下为实现这个操作的代码：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def calculate(self, s):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        res = 0</span><br><span class="line">        sign = 1</span><br><span class="line">        i = 0</span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>: <span class="comment">#空格跳过</span></span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                sign = -1</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                sign = 1</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">                tmp = int(s[i])</span><br><span class="line">                i += 1</span><br><span class="line">                <span class="comment">#验证这是不是一个非单位数，如果是的话，进入下面的while循环</span></span><br><span class="line">                <span class="keyword">while</span> i&lt;n and s[i].isdigit(): <span class="comment">#如果数字有很多位的情况</span></span><br><span class="line">                    tmp = tmp*10 + int(s[i])</span><br><span class="line">                    i += 1</span><br><span class="line">                <span class="comment">#真正的计算操作</span></span><br><span class="line">                res += tmp * sign</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure></p>
<h4 id="考虑括号，考虑加减号（第一种做法）">0.0.3.2. 考虑括号，考虑加减号（第一种做法）</h4><p>这一步则是到达了这道题目所要求的部分，也正是因为括号的出现，我们需要考虑计算的先后顺序，在这里，就要运用到<code>栈</code>。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def calculate(self, s):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        res = 0</span><br><span class="line">        sign = 1</span><br><span class="line">        i = 0</span><br><span class="line">        n = len(s)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>: <span class="comment">#空格跳过</span></span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                sign = -1</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                sign = 1</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(res)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                res = 0</span><br><span class="line">                sign = 1</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                res = res * stack.pop() + stack.pop()</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">                tmp = int(s[i])</span><br><span class="line">                i += 1</span><br><span class="line">                <span class="comment">#验证这是不是一个非单位数，如果是的话，进入下面的while循环</span></span><br><span class="line">                <span class="keyword">while</span> i&lt;n and s[i].isdigit(): <span class="comment">#如果数字有很多位的情况</span></span><br><span class="line">                    tmp = tmp*10 + int(s[i])</span><br><span class="line">                    i += 1</span><br><span class="line">                <span class="comment">#真正的计算操作</span></span><br><span class="line">                res += tmp * sign</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure></p>
<h4 id="考虑括号，考虑加减号（负雪明烛）">0.0.3.3. 考虑括号，考虑加减号（负雪明烛）</h4><p><a href="https://leetcode-cn.com/problems/basic-calculator/solution/ru-he-xiang-dao-yong-zhan-si-lu-lai-zi-y-gpca/">负雪明烛</a></p>
<p>用<code>栈</code>来实现递归。</p>
<p>一个表达式可以分为三个部分：左边表达式①，运算符③，右边表达式②</p>
<p>左边和右边的表达式可以是一个数字，也可以是一个括号包起来的表达式；运算符可以是加减。</p>
<p>先计算左边的表达式，再计算右边表达式，最后根据运算符，计算 ① 和② 的运算。</p>
<p>以<code>&quot;(1+(4+5+2)-3)+(6+8)&quot;</code>为例：</p>
<img src="/2021/03/09/224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-Hard/1615341430-TjSiGC-224.001.jpeg" class>
<p>编程思路即：先计算左边的表达式① ，把①的结果和运算符③保存在栈内，再计算右边的表达式②，最后计算① 和②的运算。</p>
<p>在有括号的情况下，栈顶保留的是最里层嵌套的运算，弹出栈的时候，正好先计算最里层括号的，再计算外边括号的。</p>
<p>代码：</p>
<ul>
<li>res 表示左边表达式除去栈内保存元素的计算结果；</li>
<li>sign 表示运算符；</li>
<li>num 表示当前遇到的数字，会更新到 res 中；</li>
<li>用栈保存遇到左括号时前面计算好了的结果和运算符。</li>
</ul>
<p>操作的步骤是：</p>
<ul>
<li>如果当前是数字，那么更新计算当前数字；</li>
<li>如果当前是操作符+或者-，那么需要更新计算当前计算的结果 res，并把当前数字 num 设为 0，sign 设为正负，重新开始；</li>
<li>如果当前是 ( ，那么说明遇到了右边的表达式，而后面的小括号里的内容需要优先计算，所以要把 res，sign 进栈，更新 res 和 sign 为新的开始；</li>
<li>如果当前是 ) ，那么说明右边的表达式结束，即当前括号里的内容已经计算完毕，所以要把之前的结果出栈，然后计算整个式子的结果；</li>
<li>最后，当所有数字结束的时候，需要把最后的一个 num 也更新到 res 中。</li>
</ul>
<img src="/2021/03/09/224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-Hard/1615341467-gaVtdq-224.002.jpeg" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def calculate(self, s):</span><br><span class="line">        res, num, sign = 0, 0, 1</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = 10 * num + int(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;+&quot;</span> or c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                res += sign * num</span><br><span class="line">                num = 0</span><br><span class="line">                sign = 1 <span class="keyword">if</span> c == <span class="string">&quot;+&quot;</span> <span class="keyword">else</span> -1</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(res)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                res = 0</span><br><span class="line">                sign = 1</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                res += sign * num</span><br><span class="line">                num = 0</span><br><span class="line">                res *= stack.pop()</span><br><span class="line">                res += stack.pop()</span><br><span class="line">        res += sign * num</span><br><span class="line">        <span class="built_in">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>227.基本计算器2(Medium)</title>
    <url>/2021/03/10/227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E6%9C%BA2-Medium/</url>
    <content><![CDATA[<p>每日一题(2021.03.11)之<a href="https://leetcode-cn.com/problems/basic-calculator-ii/">基本计算器</a><br>难度：中等</p>
<h3 id="一、题目">0.0.1. 一、题目</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p>示例 1：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;3+2*2&quot;</span></span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot; 3/2 &quot;</span></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></p>
<p>示例 3：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot; 3+5 / 2 &quot;</span></span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure></p>
<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 3 * 10^5</li>
<li>s 由整数和算符 (‘+’, ‘-‘, ‘*‘, ‘/‘) 组成，中间由一些空格隔开</li>
<li>s 表示一个 有效表达式</li>
<li>表达式中的所有整数都是非负整数，且在范围 [0, 2^31 - 1] 内</li>
<li>题目数据保证答案是一个 32-bit 整数</li>
</ul>
<h3 id="解法">0.0.2. 解法</h3><p>好亲切的连环题(误 而且一看还是个medium,比起昨天hard的残虐，稍微松了一口气。。。<br>凭着脑海里昨日的记忆，欣喜若狂的写下这个愚蠢的答案。。。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def calculate(self, s):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        sign = 0 <span class="comment"># 0 =&gt; +, 1 =&gt; - , 2 =&gt; *, 3 =&gt; /</span></span><br><span class="line">        res = 0</span><br><span class="line">        n = len(s)</span><br><span class="line">        i = 0</span><br><span class="line">        <span class="keyword">while</span> i&lt;n:</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                sign = 0</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                sign = 1</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                sign = 2</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                sign = 3</span><br><span class="line">                i += 1</span><br><span class="line">            <span class="keyword">elif</span> s[i].isdigit():</span><br><span class="line">                tmp = int(s[i])</span><br><span class="line">                i += 1</span><br><span class="line">                <span class="keyword">while</span> i&lt;n and s[i].isdigit():</span><br><span class="line">                    tmp += tmp*10 + int(s[i])</span><br><span class="line">                    i += 1</span><br><span class="line">                <span class="keyword">if</span> sign == 0:</span><br><span class="line">                    res += tmp</span><br><span class="line">                    tmp = 0</span><br><span class="line">                <span class="keyword">elif</span> sign == 1:</span><br><span class="line">                    res -= tmp</span><br><span class="line">                    tmp = 0</span><br><span class="line">                <span class="keyword">elif</span> sign == 2:</span><br><span class="line">                    res *= tmp</span><br><span class="line">                    tmp = 0</span><br><span class="line">                <span class="keyword">elif</span> sign == 3:</span><br><span class="line">                    res /= tmp</span><br><span class="line">                    tmp = 0</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure><br>这个答案在遇到第一个示例<code>s=&quot;3+3*2</code>时就通过不了了，忘记了乘除法比加减法优先计算了。。。这就叫做乐极生悲吗</p>
<p>然后我又不识好歹的写下了这个答案逃之夭夭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def calculate(self, s):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">eval</span>(s)</span><br></pre></td></tr></table></figure>
<p>说正经的，当有加减乘除四种运算符时，考虑运算符优先级别，所以<strong>思路</strong>就是利用<code>栈</code>，假如遇到的是<code>数字</code>、<code>+</code>、<code>-</code>号时直接入栈（<code>-</code>换成<code>-num</code>入栈，之后就可以用<code>sum(stack)</code>返回结果了。遇到<code>*</code>,<code>/</code>的时候先把栈顶弹出，计算完结果后再保存回栈顶。</p>
<p>这里要注意一个python的细节，<code>//</code>和<code>/</code>的定义不同。<code>//</code>为向下取整，比如<code>(-3)//2 = -2</code>。我们不需要取整，<code>-(abs(一个负数)/num)</code>通过这个方式，就可以正确求职。</p>
<p>思路代码参考<a href="https://leetcode-cn.com/problems/basic-calculator-ii/solution/xian-cheng-chu-zai-jia-jian-yong-zhan-ba-hplr/">负雪明烛</a> 这肯定是个小天使姐姐</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def calculate(self, s):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        pre_op = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        num = 0</span><br><span class="line">        <span class="keyword">for</span> i,each <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> each.isdigit():</span><br><span class="line">                num = num*10 + int(each)</span><br><span class="line">            <span class="keyword">if</span> i == len(s)-1 or each <span class="keyword">in</span> <span class="string">&#x27;+-*/&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> pre_op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> pre_op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> pre_op == <span class="string">&#x27;*&#x27;</span>:<span class="comment">#遇到乘法，栈顶跳出计算，结果再储存</span></span><br><span class="line">                    stack.append(stack.pop()*num)</span><br><span class="line">                <span class="keyword">elif</span> pre_op == <span class="string">&#x27;/&#x27;</span>:<span class="comment">#遇到除法，栈顶跳出计算，结果再储存</span></span><br><span class="line">                    top = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> top &lt; 0:</span><br><span class="line">						<span class="comment">#这句稍有不同</span></span><br><span class="line">                        stack.append(-(abs(top)/num))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack.append(top//num)</span><br><span class="line">                pre_op = each</span><br><span class="line">                num = 0</span><br><span class="line"></span><br><span class="line">        <span class="comment">#由于栈内只有数字了（减法用负数表示），直接求和</span></span><br><span class="line">        <span class="built_in">return</span> sum(stack)</span><br></pre></td></tr></table></figure>
<p>这道题比起昨天的hard模式不是非常难，但是也是细节满满，学到了</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>331.验证二叉树的前序序列化(Medium)</title>
    <url>/2021/03/12/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96-Medium/</url>
    <content><![CDATA[<p>LeetCode每日一题系列（2021.03.12)之<a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree">验证二叉树的前序序列化</a><br>难度：中等</p>
<h3 id="题目">0.0.1. 题目</h3><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如<code>#</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    /   \</span><br><span class="line">   3     2</span><br><span class="line">  / \   / \</span><br><span class="line"> 4   1  <span class="comment">#  6</span></span><br><span class="line">/ \ / \   / \</span><br><span class="line"><span class="comment"># # # #   # #</span></span><br></pre></td></tr></table></figure>
<p>例如，上面的二叉树可以被序列化为字符串<code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 # 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。</p>
<p>示例 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p>
<p>示例 3:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;9,#,#,1&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解法">0.0.2. 解法</h3><p>还是参考<a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/pai-an-jiao-jue-de-liang-chong-jie-fa-zh-66nt/">负雪明烛大神</a>的两种解法。</p>
<p>我做了好长时间这道题，一直卡在了一种case上：<br>当char已经遍历完，最后三个字符刚好是符合<code>9,#,#</code>转换为<code>#</code>这种情况的，但由于我没有利用好while导致一直没有得到正确的答案，而且代码又臭又长，深感水平太差啊。。。</p>
<h4 id="利用栈的做法">0.0.2.1. 利用栈的做法</h4><p>首先要明确的是树的<strong>前序遍历</strong>是按照<code>根节点，左子树，右子树</code>的顺序来排列的，那<code>9,#,#</code>代表一个两个孩子都为空的节点，即它是一个<code>叶子节点</code>；当一个节点不是<code>叶子节点</code>时，有两种情况：1）两个孩子都非#（空）2）一个孩子为空，一个孩子不为空。</p>
<p>这道题的重点思路来了：</p>
<ul>
<li>把有效的<code>叶子节点</code>用<code>#</code>代替，比如把<code>4##</code>换成<code>#</code>。</li>
</ul>
<p>具体操作流程示例如下：</p>
<p>如输入： “9,3,4,#,#,1,#,#,2,#,6,#,#” ，当遇到 x,#,# 的时候，就把它变为 #。</p>
<p>模拟一遍过程：</p>
<p>[9,3,4,#,#] =&gt; [9,3,#]，继续<br>[9,3,#,1,#,#] =&gt; [9,3,#,#] =&gt; [9,#] ，继续<br>[9,#2,#,6,#,#] =&gt; [9,#,2,#,#] =&gt; [9,#,#] =&gt; [#]，结束<br>下面的动画模拟了”9,3,4,#,#,1,#,#,#”的操作过程：</p>
<img src="/2021/03/12/331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96-Medium/1615551708-uxodPT-331.gif" class>
<p>代码比较简单，最需要注意的还是这个for循环里精准的while：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isValidSerialization(self, preorder):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type preorder: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> preorder.split(<span class="string">&#x27;,&#x27;</span>):</span><br><span class="line">            stack.append(node)</span><br><span class="line">            <span class="keyword">while</span> len(stack) &gt;= 3 and stack[-1] == <span class="string">&#x27;#&#x27;</span> and stack[-2] == <span class="string">&#x27;#&#x27;</span> and stack[-3].isdigit():</span><br><span class="line">                stack = stack[:-3] <span class="comment">#stack.pop(),stack.pop(),stack.pop()</span></span><br><span class="line">                stack.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> len(stack) == 1 and stack.pop() == <span class="string">&#x27;#&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>时间复杂度:O(N)</li>
<li>空间复杂度:O(N)</li>
</ul>
<h4 id="计算入度出度-（还未掌握）">0.0.2.2. 计算入度出度 （还未掌握）</h4><p>除了负雪明烛用了这个办法，另外一个超棒的博主<a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/shou-hua-tu-jie-cong-ling-yi-ge-jiao-du-2rnzg/">笨猪爆破组</a>也是写的这个方法，等待学习！</p>
<p>背景知识：</p>
<ul>
<li><strong>入度</strong>: 有多少个节点指向它</li>
<li><strong>出度</strong>：它指向多少个节点</li>
</ul>
<p>在树中，<code>所有节点的入度之和等于出度之和</code>。故，可以通过这个特点判断输入序列是否为有效的！</p>
<p>在一棵二叉树中：</p>
<ul>
<li>每个空节点（ “#” ）会提供 0 个出度和 1 个入度。</li>
<li>每个非空节点会提供 2 个出度和 1 个入度（根节点的入度是 0）。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1615552473-UUReDo-331%E8%BD%AC%E5%9B%BE%E7%89%87.003.jpeg" alt="image"></p>
<p>我们只要把字符串遍历一次，每个节点都累加 diff = 出度 - 入度 。在遍历到任何一个节点的时候，要求diff &gt;= 0，原因是还没遍历到该节点的子节点，所以此时的出度应该大于等于入度。当所有节点遍历完成之后，整棵树的 diff == 0 。</p>
<p>这里解释一下为什么下面的代码中 diff 的初始化为 1。因为，我们加入一个非空节点时，都会对 diff 先减去 1（入度），再加上 2（出度）。但是由于根节点没有父节点，所以其入度为 0，出度为 2。因此 diff 初始化为 1，是为了在加入根节点的时候，diff 先减去 1（入度），再加上 2（出度），此时 diff 正好应该是2.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isValidSerialization(self, preorder):</span><br><span class="line">        nodes = preorder.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        diff = 1</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            diff -= 1</span><br><span class="line">            <span class="keyword">if</span> diff &lt; 0:</span><br><span class="line">                <span class="built_in">return</span> False</span><br><span class="line">            <span class="keyword">if</span> node != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                diff += 2</span><br><span class="line">        <span class="built_in">return</span> diff == 0</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>395.至少有K个重复字符的最长子串(Medium)</title>
    <url>/2021/02/27/395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-Medium/</url>
    <content><![CDATA[<p>力扣每日一题系列(2021.02.27)之<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">至少有K个重复字符的最长子串</a><br>难度:中等</p>
<h3 id="一、题目">0.0.1. 一、题目</h3><p>给你一个字符串<code>s</code>和一个整数<code>k</code>,请你找出<code>s</code>中的最长子串,要求该子串中的每一字符出现次数都不少于<code>k</code>.返回这一子串的长度.</p>
<p>示例1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;aaabb&quot;</span>, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：最长子串为 <span class="string">&quot;aaa&quot;</span> ，其中 <span class="string">&#x27;a&#x27;</span> 重复了 3 次。</span><br></pre></td></tr></table></figure></p>
<p>示例2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ababbc&quot;</span>, k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子串为 <span class="string">&quot;ababb&quot;</span> ，其中 <span class="string">&#x27;a&#x27;</span> 重复了 2 次， <span class="string">&#x27;b&#x27;</span> 重复了 3 次。</span><br></pre></td></tr></table></figure></p>
<p>提示:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= s.length &lt;= 104</span><br><span class="line">s 仅由小写英文字母组成</span><br><span class="line">1 &lt;= k &lt;= 105</span><br></pre></td></tr></table></figure></p>
<h3 id="我的解法-30-31ac">0.0.2. 我的解法(30/31ac)</h3><p>我的想法是先设定一个判断用的函数<code>issubstring</code>用于判断每一个我截取下来的子串,在这个func里,通过<code>哈希表</code>的方法来判断字符重复次数是否大于k,如果全部大于,返回<code>True</code>否则返回<code>False</code>.</p>
<p>同是判断两个边缘条件: 1)如果整个字符串为<code>True</code>,那就不经过下面的小循环,直接返回<code>len(s)</code> 2)如果<code>k</code>的数量大于<code>len(s)</code>那不可能满足,返回0.</p>
<p>在接下来的循环中,具体细节如下图:<br></p>
<p>但是其中<code>continue</code>这个想法是错误的,比如当下的substring可能不是符合条件的,但是后续补充了一些字符之后有可能这个substring是符合的,所以这种简化方法不可取,感觉这道题的用例并不是非常完全,最后这段代码只是遇到了特别长的用例时出现了时间问题,但没有遇到我提到的这个问题.</p>
<p>接下来是这段代码:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestSubstring(self, s, k):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        def issubstring(s,k):</span><br><span class="line">            m = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> char <span class="keyword">in</span> m:</span><br><span class="line">                    m[char] += 1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    m[char] = 1</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> m:</span><br><span class="line">                <span class="keyword">if</span> m[char]&lt;k:</span><br><span class="line">                    <span class="built_in">return</span> False</span><br><span class="line">            <span class="built_in">return</span> True</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> issubstring(s,k):</span><br><span class="line">            <span class="built_in">return</span> len(s)</span><br><span class="line">        <span class="keyword">elif</span> k &gt; len(s):</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line">        maxlen = 0</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+k-1,len(s)):</span><br><span class="line">                subs = s[i:j+1]</span><br><span class="line">                <span class="comment">#print(subs)</span></span><br><span class="line">                <span class="keyword">if</span> issubstring(subs,k):</span><br><span class="line">                    maxlen = max(maxlen,len(subs))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#这个continue的想法是错误的</span></span><br><span class="line">                    <span class="built_in">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> maxlen</span><br></pre></td></tr></table></figure></p>
<h3 id="递归做法">0.0.3. 递归做法</h3><p>依然是参考了<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/">负雪明烛</a>的解析,这个递归我一开始有想到过,用split的方法反复切割,但是自己思路不好,就换成了上面那种做法,而且递归我一直学习的很差,得加把劲啊.</p>
<p>先上她的原版代码:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestSubstring(self, s, k):</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; k:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s.count(c) &lt; k:</span><br><span class="line">                <span class="built_in">return</span> max(self.longestSubstring(t, k) <span class="keyword">for</span> t <span class="keyword">in</span> s.split(c))</span><br><span class="line">        <span class="built_in">return</span> len(s)</span><br></pre></td></tr></table></figure><br>接下来整理整理思路:</p>
<ul>
<li>递归的重点: 牢记递归函数的输入输出是什么(这里的输入是字符串,限定条件是<code>k</code>,输出是满足条件的最长字符子串长度)</li>
<li>递归的终止条件: 如果<code>字符串s</code>的长度小于<code>k</code>,那么一定不存在符合条件的子串,直接返回0</li>
<li>递归的调用法则: 如果一个<code>字符c</code>在<code>s</code>中出现的次数少于<code>k次</code>,那么所有包含<code>字符c</code>的子字符串一定不符合规定.所以,应该通过某种方法将<code>字符c</code>排除在外,方法:把<code>s</code>按照<code>字符c</code>分割(分割后的每一个子串都不包含<code>字符c</code>),得到很多<code>子串t</code>. 而得到的<code>t</code>,就是未来的<code>s&#39;</code>. 下一步,<code>不含字符c的子串们t</code>就是作为<code>longestSubstring(s, k)</code>的新输入,大问题分割为了小问题,形成递归.</li>
<li>未进入递归即返回结果的情况: 如果<code>s</code>中的每个字符都满足大于<code>重复次数k</code>次的这个条件,那么直接返回<code>len(s)</code>.</li>
</ul>
<p>复杂度分析:</p>
<ul>
<li>时间复杂度: O(N*26*26) 因为函数最多执行26次(小写的26个英语字符),for循环遍历一遍是26个字符,循环里面对s分割时间的复杂度为O(N)</li>
<li>空间复杂度: O(26*26), 函数执行26次,每次开辟26个字符的set空间</li>
</ul>
<p>读聪明人的代码就是茅塞顿开的感觉,特别喜欢这个刷题姐姐的讲解</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>451.根据字符出现频率排序</title>
    <url>/2021/07/03/451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>LeetCode每日一题之<a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451.根据字符出现频率排序</a>。</p>
<p>今天这题比较简单，周六愉快</p>
<p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<h3 id="题目">0.0.1. 题目</h3><p>示例 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">&quot;tree&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;eert&quot;</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="string">&#x27;e&#x27;</span>出现两次，<span class="string">&#x27;r&#x27;</span>和<span class="string">&#x27;t&#x27;</span>都只出现一次。</span><br><span class="line">因此<span class="string">&#x27;e&#x27;</span>必须出现在<span class="string">&#x27;r&#x27;</span>和<span class="string">&#x27;t&#x27;</span>之前。此外，<span class="string">&quot;eetr&quot;</span>也是一个有效的答案。</span><br></pre></td></tr></table></figure></p>
<p>示例 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">&quot;cccaaa&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;cccaaa&quot;</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="string">&#x27;c&#x27;</span>和<span class="string">&#x27;a&#x27;</span>都出现三次。此外，<span class="string">&quot;aaaccc&quot;</span>也是有效的答案。</span><br><span class="line">注意<span class="string">&quot;cacaca&quot;</span>是不正确的，因为相同的字母必须放在一起。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">&quot;Aabb&quot;</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="string">&quot;bbAa&quot;</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，<span class="string">&quot;bbaA&quot;</span>也是一个有效的答案，但<span class="string">&quot;Aabb&quot;</span>是不正确的。</span><br><span class="line">注意<span class="string">&#x27;A&#x27;</span>和<span class="string">&#x27;a&#x27;</span>被认为是两种不同的字符。</span><br></pre></td></tr></table></figure>
<h3 id="我的解法">0.0.2. 我的解法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def frequencySort(self, s):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 哈希表</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> not ch <span class="keyword">in</span> d:</span><br><span class="line">                d[ch] = 1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[ch] += 1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把字典按value的大小从大到小排序</span></span><br><span class="line">        a = sorted(d.items(), key=lambda x: x[1], reverse=True)</span><br><span class="line">        </span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> aa <span class="keyword">in</span> a:</span><br><span class="line">            <span class="comment"># 小坑：出现多次的字母需要+=多次</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(aa[1]):</span><br><span class="line">                res += str(aa[0])</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是因为相当于最多遍历了两次字典，时间还是比较慢的<br>平平无奇小代码吧。。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>54.螺旋矩阵(Medium)</title>
    <url>/2021/03/17/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-Medium/</url>
    <content><![CDATA[<p>LeetCode每日一题(2021.03.15)之<a href="https://leetcode-cn.com/problems/spiral-matrix/">螺旋矩阵</a><br>难度：中等</p>
<h3 id="题目">0.0.1. 题目</h3><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p>示例1:</p>
<img src="/2021/03/17/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-Medium/spiral1.jpeg" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<img src="/2021/03/17/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-Medium/spiral.jpeg" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 10</li>
<li>-100 &lt;= matrix[i][j] &lt;= 100</li>
</ul>
<h3 id="解法1">0.0.2. 解法1</h3><p><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/ju-zhen-bian-li-wen-ti-de-si-bu-qu-by-fu-91za/">负雪明烛</a></p>
<h4 id="思路">0.0.2.1. 思路</h4><p>在<strong>打印矩阵</strong>类似的题目中，要考虑以下几个问题：</p>
<ul>
<li>起始位置</li>
<li>移动方向</li>
<li>边界</li>
<li>结束条件</li>
</ul>
<h5 id="起始位置">0.0.2.1.1. 起始位置</h5><p><strong>螺旋矩阵</strong>的遍历起始于矩阵的左上角<code>(0,0)</code>。</p>
<h5 id="移动方向">0.0.2.1.2. 移动方向</h5><p>起始位置的下一个移动方向是向右。在遍历的过程中，移动的方向是固定的：</p>
<ul>
<li>右</li>
<li>下</li>
<li>左</li>
<li>上</li>
</ul>
<p>移动的方向按照上面的顺序进行，每次移动到了<strong>边界</strong>，才会更改方向，但<strong>边界并不是固定的</strong>。</p>
<h5 id="边界">0.0.2.1.3. 边界</h5><p>本题中，<strong>边界</strong>随着遍历的过程而改变，已经遍历过的位置不再遍历，边界会越来越小。</p>
<p>规则是：<strong>如果当前行（列）遍历结束后，就把这一行（列）的边界向内移动一格。</strong></p>
<p>以下面的图为例，<code>up, down, left, right</code> 分别表示四个方向的边界，初始时分别指向矩阵的四个边界。如果我们把第一行遍历结束（遍历到了右边界），此时需要修改新的移动方向为向下、并且把上边界 <code>up</code> 下移一格，即从<code>旧up</code> 位置移动到 <code>新up</code> 位置。</p>
<img src="/2021/03/17/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-Medium/upleft.jpeg" class>
<p>当绕了一圈后，从下向上走到 <code>新up</code> 边界的时候，此时需要<code>修改新的移动方向为向右</code>、并且<code>把左边界 left 下移一格</code>，即从 旧<code>left</code> 位置移动到 <code>新left</code> 位置。</p>

<h5 id="结束条件">0.0.2.1.4. 结束条件</h5><p>螺旋遍历的结束条件是所有的位置都被遍历到。</p>
<h4 id="代码">0.0.2.2. 代码</h4><ul>
<li><code>up, down, left, right</code> 分别表示四个方向的边界</li>
<li><code>x,y</code> 表示当前位置</li>
<li><code>dirs</code> 表示移动的方向是<code>右，下，左，上</code></li>
<li>cur_d 表示当前的移动方向的下标，dirs[cur_d] 就是下一个方向需要怎么修改 x, y。</li>
<li><code>cur\_d == 0 and y == right</code> 表示当前的移动方向是向右，并且到达了右边界，此时将移动方向更改为向下，并且上边界 up 向下移动一格。</li>
<li>结束条件是结果数组 res 的元素个数能与 matrix 中的元素个数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def spiralOrder(self, matrix):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 排除边界条件</span></span><br><span class="line">        <span class="keyword">if</span> not matrix or not matrix[0]: <span class="built_in">return</span> []</span><br><span class="line">        M, N = len(matrix), len(matrix[0]) <span class="comment"># M =&gt; 行数， N =&gt; 列数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#定义四个方向的边界</span></span><br><span class="line">        left, right, up, down = 0, N-1, 0, M-1</span><br><span class="line">        <span class="comment">#定义当前位置</span></span><br><span class="line">        x, y = 0, 0</span><br><span class="line">        <span class="comment">#定义四个移动方向 [右，下，左，上]</span></span><br><span class="line">        <span class="built_in">dirs</span> = [(0, 1), (1, 0), (0, -1), (-1, 0)]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        cur_d = 0</span><br><span class="line"></span><br><span class="line">        <span class="comment">#当res里的数量不等于M*N时</span></span><br><span class="line">        <span class="keyword">while</span> len(res) != M * N:</span><br><span class="line">            res.append(matrix[x][y])</span><br><span class="line">            <span class="keyword">if</span> cur_d == 0 and y == right:</span><br><span class="line">                cur_d += 1</span><br><span class="line">                up += 1</span><br><span class="line">            <span class="keyword">elif</span> cur_d == 1 and x == down:</span><br><span class="line">                cur_d += 1</span><br><span class="line">                right -= 1</span><br><span class="line">            <span class="keyword">elif</span> cur_d == 2 and y == left:</span><br><span class="line">                cur_d += 1</span><br><span class="line">                down -= 1</span><br><span class="line">            <span class="keyword">elif</span> cur_d == 3 and x == up:</span><br><span class="line">                cur_d += 1</span><br><span class="line">                left += 1</span><br><span class="line">            cur_d %= 4</span><br><span class="line">            x += <span class="built_in">dirs</span>[cur_d][0]</span><br><span class="line">            y += <span class="built_in">dirs</span>[cur_d][1]</span><br><span class="line">        <span class="built_in">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解法2-（利用zip函数）">0.0.3. 解法2 （利用zip函数）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def spiralOrder(self, matrix):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res += matrix.pop(0)  <span class="comment">#每次提取第一排元素</span></span><br><span class="line">            matrix = list(zip(*matrix))[::-1]   <span class="comment">#将剩余的元素进行逆时针旋转九十度</span></span><br><span class="line">        <span class="built_in">return</span> res</span><br></pre></td></tr></table></figure>
<p>更喜欢第二种解法 :)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>打印矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>692.前K个高频单词(Medium)</title>
    <url>/2021/05/21/692-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D-Medium/</url>
    <content><![CDATA[<p>LeetCode每日一题(2021.05.20)之<a href="https://leetcode-cn.com/problems/top-k-frequent-words/">前k个高频单词</a><br>难度: 中等</p>
<p>给一非空的单词列表，返回前 k 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>
<p>示例1：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;leetcode&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;coding&quot;</span>], k = 2</span><br><span class="line">输出: [<span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>]</span><br><span class="line">解析: <span class="string">&quot;i&quot;</span> 和 <span class="string">&quot;love&quot;</span> 为出现次数最多的两个单词，均为2次。</span><br><span class="line">    注意，按字母顺序 <span class="string">&quot;i&quot;</span> 在 <span class="string">&quot;love&quot;</span> 之前。</span><br></pre></td></tr></table></figure></p>
<p>示例2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;is&quot;</span>], k = 4</span><br><span class="line">输出: [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;sunny&quot;</span>, <span class="string">&quot;day&quot;</span>]</span><br><span class="line">解析: <span class="string">&quot;the&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;sunny&quot;</span> 和 <span class="string">&quot;day&quot;</span> 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。</li>
<li>输入的单词均由小写字母组成。</li>
</ul>
<h3 id="解析">0.0.1. 解析</h3><p>利用双字典排列：</p>
<ol>
<li>第一次排列：自带工具collections.Counter计算给出列表words里每一个单词的出现顺序</li>
<li>第二次排列：按照词频（从大到小）和单词顺序（从小到大）的方式排序，利用lambda</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def topKFrequent(self, words, k):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">#双排列</span></span><br><span class="line"></span><br><span class="line">        dic = collections.Counter(words)  <span class="comment">#计算词频</span></span><br><span class="line">        res = sorted(dic,key = lambda word:(-dic[word],word)) <span class="comment">#词频倒序，字母正序</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> res[:k]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>7.整数反转(Easy)</title>
    <url>/2021/03/10/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-Easy/</url>
    <content><![CDATA[<p>LeetCode之<a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a><br>难度：简单</p>
<h3 id="一、题目">0.0.1. 一、题目</h3><p>给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<p>示例 1：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure></p>
<p>示例 3：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：x = 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure></p>
<p>示例 4：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：x = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></p>
<p>提示：</p>
<p><code>-2**31 &lt;= x &lt;= 2**31 - 1</code></p>
<h3 id="二、我的解法">0.0.2. 二、我的解法</h3><p><code>24ms, 83.28%; 12.9MB, 76.51%</code></p>
<p>因为在Python里，<code>int</code>没有长度，所以将其转换为<code>str</code>来获得其长度信息，代码很简单，主要是为了在第三部分学习他人<strong>简洁的代码</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        flag = False</span><br><span class="line">        <span class="keyword">if</span> x &lt; 0:</span><br><span class="line">            flag = True</span><br><span class="line">            x = -x</span><br><span class="line">        </span><br><span class="line">        n = len(str(x))</span><br><span class="line">        res = 0</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i,ch <span class="keyword">in</span> enumerate(str(x)[::-1]):</span><br><span class="line">            res += int(ch) * (10 ** (n-i-1))</span><br><span class="line"></span><br><span class="line">        res = -res <span class="keyword">if</span> flag <span class="keyword">else</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> -2**31&lt;res&lt;2**31-1:</span><br><span class="line">            <span class="built_in">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br></pre></td></tr></table></figure>
<h3 id="三、他人的解法">0.0.3. 三、他人的解法</h3><p>如下参考<a href="https://leetcode-cn.com/problems/reverse-integer/solution/jin-tian-xiao-bai-jie-ti-ta-lai-liao-by-cuive/">Will</a></p>
 <img src="/2021/03/10/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC-Easy/1610776376-AunReA-%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC.jpeg" class>
<p>例子：1234 =&gt; 4321</p>
<p>这是一个4位的数字，个位数转换后变成了千位，十位变成了百位…</p>
<p>但是在这道题中，输入数字x的大小无法确定</p>
<p>思路为每次截取x的最后一位，按照倍数变化操作，通过while来完成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">	def reverse(self, x):</span><br><span class="line">		a = 0</span><br><span class="line">		<span class="keyword">while</span> x!=0:</span><br><span class="line">			<span class="keyword">if</span> x&gt;0:</span><br><span class="line">				a=a*10+x%10</span><br><span class="line">				x = x//10</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				a=a*10+x%-10</span><br><span class="line">				x = -(x//-10)</span><br><span class="line">		<span class="built_in">return</span> a if-2**31&lt;a&lt;2**31-1 <span class="keyword">else</span> 0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>856.转置矩阵(Easy)</title>
    <url>/2021/02/25/856-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>力扣每日一题系列(2021.02.25)之<a href="https://leetcode-cn.com/problems/transpose-matrix/">转置矩阵</a><br>难度：简单</p>
<h2 id="一、题目">0.1. 一、题目</h2><p>给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。<br>矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png" alt="867.转置矩阵"></p>
<h3 id="示例">0.1.1. 示例</h3><p>示例1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ 输入: matrix&#x3D;[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">$ 输出: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure></p>
<p>示例2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure><br>提示：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 1000</span><br><span class="line">1 &lt;= m * n &lt;= 105</span><br><span class="line">-10^9 &lt;= matrix[i][j] &lt;= 10^9</span><br></pre></td></tr></table></figure></p>
<h3 id="我的解法">0.1.2. 我的解法</h3><p>转置矩阵即将M行N列的矩阵，转换成N行M列的矩阵，注意有可能N和M并不相等，所以必须要新建一个result矩阵（否则可能会出现out of range的情况）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def transpose(self, matrix):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        m,n = len(matrix),len(matrix[0])</span><br><span class="line">        <span class="comment">#m为行数，n为列数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#不需要numpy的矩阵建造方法</span></span><br><span class="line">        new_matrix = [[0 <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                new_matrix[i][j] = matrix[j][i]</span><br><span class="line">        <span class="built_in">return</span> new_matrix</span><br></pre></td></tr></table></figure>
<p>这道题的意思就是原来的每一行转换成了后来的每一列，为了数学关系上更清晰，下面图片为解析。可以看出，对于一个相同的元素，新地址（坐标）和旧地址（坐标）就是横纵轴交换的关系：<br><img src="/2021/02/25/856-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/jiexi.png" class title="This is an example image"></p>
<p>一个错误的思路：（这个思路就是没有考虑到新矩阵的大小关系）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(n):</span><br><span class="line">	for j in range(i,m):</span><br><span class="line">		matrix[i][j], matrix[j][i] &#x3D;  matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>92.反转链表2(Medium)-未掌握</title>
    <url>/2021/03/18/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-Medium/</url>
    <content><![CDATA[<p>LeetCode每日一题(2021.03.18)之<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表2</a></p>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<p>示例1:</p>
<img src="/2021/03/18/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-Medium/rev2ex2.jpeg" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [5], left = 1, right = 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>：</p>
<ul>
<li>链表中节点数目为 n</li>
<li>1 &lt;= n &lt;= 500</li>
<li>-500 &lt;= Node.val &lt;= 500</li>
<li>1 &lt;= left &lt;= right &lt;= n</li>
</ul>
<p><strong>进阶</strong>：<br>你可以使用一趟扫描完成反转吗？</p>
<h3 id="解法">0.0.1. 解法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line">class Solution(object):</span><br><span class="line">    def reverseBetween(self, head, left, right):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type left: int</span></span><br><span class="line"><span class="string">        :type right: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        count = 1</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(0)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        </span><br><span class="line">        pre = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pre.next and count &lt; left:</span><br><span class="line">            pre = pre.next</span><br><span class="line">            count += 1</span><br><span class="line"></span><br><span class="line">        cur = pre.next</span><br><span class="line">        tail = cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur and count &lt;= right:</span><br><span class="line">            nxt = cur.next</span><br><span class="line">            cur.next = pre.next</span><br><span class="line">            pre.next = cur</span><br><span class="line">            tail.next = nxt</span><br><span class="line">            cur = nxt</span><br><span class="line">            count += 1</span><br><span class="line">        <span class="built_in">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>C++运算符及类型转化问题</title>
    <url>/2021/08/09/C-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="C-数学运算符">1. C++ 数学运算符</h1><h2 id="5种基本的C-运算符">1.1. 5种基本的C++运算符</h2><ul>
<li><ul>
<li>加法运算</li>
</ul>
</li>
<li><ul>
<li>减法运算</li>
</ul>
</li>
<li><ul>
<li>乘法运算</li>
</ul>
</li>
<li>/ 除法运算（如果两个操作数都是整数，则执行整数除法，小数部分将被丢弃，结果为整数；如果有1个（或2个）操作数是浮点数，则小数部分将被保留，结果为浮点数）</li>
<li>% 求模。两个操作数必须都为整数</li>
</ul>
<h2 id="类型转换">1.2. 类型转换</h2><h3 id="初始化和赋值进行的转换">1.2.1. 初始化和赋值进行的转换</h3><p>C++允许将一种类型的值赋给另一种类型的变量，这样做时，<strong>值将被转换为接受变量的类型</strong>。</p>
<p>🍑 例子：</p>
<p>假设so_long的类型为long，thirty的类型为short，而程序为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">so_long &#x3D; thirty; </span><br></pre></td></tr></table></figure><br>程序将thirty的值（short）扩展为long值，so_long将储存这个值，而thirty不变。</p>
<hr>
<p>将一个值赋给取值范围更大的类型通常不会产生问题，反之，则会降低精度；</p>
<p>下面列出了<strong>潜在的问题</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">转换</th>
<th style="text-align:center">潜在的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">将较大浮点类型转换为较小的浮点类型，如将double转换为float</td>
<td style="text-align:center">精度有效数位丢失</td>
</tr>
<tr>
<td style="text-align:center">将浮点转整数</td>
<td style="text-align:center">小数部分丢失</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>将0赋给bool变量时，将被转换为false；而非零值将被转换为true；</li>
</ul>
<h3 id="以-方式初始化时进行的转换">1.2.2. 以{}方式初始化时进行的转换</h3><h3 id="表达式中的转换">1.2.3. 表达式中的转换</h3><h3 id="传递参数时的转换">1.2.4. 传递参数时的转换</h3><h3 id="强制类型转换">1.2.5. 强制类型转换</h3><h3 id="C-11-中的auto声明">1.2.6. C++ 11 中的auto声明</h3><p>auto声明让编译器能够根据初始值的类型推断变量的类型。如果使用了关键字auto，而不指定变量的类型，编译器将把变量的类型设置与初始值相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto n &#x3D; 100; &#x2F;&#x2F; n is int</span><br><span class="line">auto x &#x3D; 1.5; &#x2F;&#x2F; x is double（疑问：这里x也可以是float吗）</span><br><span class="line">auto y &#x3D; 1.3e12L &#x2F;&#x2F; y is long double</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>C++里的数据类型</title>
    <url>/2021/08/09/C-%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="C-数据类型：整型，bool，char和浮点型">1. C++数据类型：整型，bool，char和浮点型</h1><h2 id="整型">1.1. 整型</h2><p><strong>C++内置的整型</strong> —— unsigned long, long, unsigned int, int, unsigned short, short, char, unsigned char, signed char, bool 和 unsigned long long, long long (C++ 11新增)</p>
<h3 id="整型short-int-long-和-long-long">1.1.1. 整型short, int, long 和 long long</h3><p>计算机内存由一些叫做位(bit)的单元组成，C++的short, int, long和long long分别用<code>不同数目的位</code>来储存值，最多能够表示4种不同的整数宽度。</p>
<p>如果在所有的系统中，<code>每种类型的宽度都相同</code>，则使用起来十分方便。例如，short总是16位，int总是32位，<strong>但生活并非那么简单</strong>，C++提供了另一种灵活的标准：</p>
<ul>
<li>short 至少16位(2 bytes.)</li>
<li>int 至少与short一样长(4 bytes.)</li>
<li>long 至少32位，且至少与int一样长 (8 bytes.)</li>
<li>long long 至少64位，且至少与long一样长 (8 bytes.)</li>
</ul>
<h3 id="无符号类型-unsigned">1.1.2. 无符号类型 unsigned</h3><p><strong>unsigned 是unsigned int的缩写</strong></p>
<p>如果short表示的范围为-32768到+32767，则无符号版本的表示范围为0-65535，当然，仅当数值不会为负时才应使用无符号类型，如人口等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned short change;</span><br><span class="line">unsigned int rovert;</span><br><span class="line">unsigned rovertt; &#x2F;&#x2F; also unsigned int</span><br><span class="line">unsigned long gone;</span><br><span class="line">unsigned long long lang_lang;</span><br></pre></td></tr></table></figure>
<h3 id="整数字面型（进制问题）">1.1.3. 整数字面型（进制问题）</h3><p>C++ 使用前一（两）位来标识数字常量的基数。</p>
<ul>
<li>如果<strong>第一位为1 —— 9</strong> 则<code>基数为10（十进制）</code></li>
<li>如果<strong>第一位是0，第二位为1——7</strong>，则<code>基数为8（八进制）</code></li>
<li>如果<strong>前两位为0x或0X</strong>，则<code>基数为16（十六进制）</code></li>
</ul>
<p>pseudo code如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int chest &#x3D; 42;     &#x2F;&#x2F; decimal integer literal 十进制</span><br><span class="line">int waist &#x3D; 0x42;   &#x2F;&#x2F; hexadecimal integer literal 十六进制</span><br><span class="line">int inseam &#x3D; 042; &#x2F;&#x2F; octal interger literal 八进制</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在cout输出下：</span><br><span class="line"></span><br><span class="line">chest &#x3D; 42 (42 in decimal)</span><br><span class="line">waist &#x3D; 66 (0x42 in hex)</span><br><span class="line">inseam &#x3D; 34 (042 in octal)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="char类型：字符和小整数">1.1.4. char类型：字符和小整数</h3><p><code>char类型</code>是专门为储存字符（如字母和数字）而设计的。char类型也是一种整型，它足够长，能够表示目标计算机系统中的所有基本符号——字母，数字和标点符号等。char最常被用来处理字符，但也可以将它比作比short更小的整型。</p>
<p>最常用的符号集为ASCII字符集。<br>例如字符A的编码为65，字母M的编码为77等。</p>
<p>cin输入时，cin将键盘中输入的M转换为77；输出时，cout将77转换为所显示的字符M；cin和cout的行为都是由变量类型（ch）引导的。</p>
<p>C++对字符用单引号<code>&#39;M&#39;</code>对字符串用双引号。</p>
<p><code>cout.put()</code>为成员函数，提供了一个显示字符的方法，可以代替<code>cout &lt;&lt;</code></p>
<p>⚠️ <strong> 注意是字符而非字符串 </strong></p>
<p>亲测<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout.put(&#39;M&#39;); &#x2F;&#x2F; valid</span><br><span class="line">cout.put(&#39;My&#39;); &#x2F;&#x2F; non valid</span><br><span class="line">cout.put(&quot;My bag&quot;); &#x2F;&#x2F; non valid</span><br></pre></td></tr></table></figure></p>
<h3 id="C-转义序列的编码">1.1.5. C++转义序列的编码</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符名称</th>
<th>C++代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">换行符</td>
<td>\n</td>
</tr>
<tr>
<td style="text-align:left">退格</td>
<td>\n</td>
</tr>
<tr>
<td style="text-align:left">回车</td>
<td>\r</td>
</tr>
<tr>
<td style="text-align:left">反斜杠</td>
<td>\\</td>
</tr>
<tr>
<td style="text-align:left">问号</td>
<td>\?</td>
</tr>
<tr>
<td style="text-align:left">单引号</td>
<td>\’</td>
</tr>
<tr>
<td style="text-align:left">双引号</td>
<td>\”</td>
</tr>
</tbody>
</table>
</div>
<h3 id="bool-类型">1.1.6. bool 类型</h3><p>bool布尔变量的值可以是true或false<br>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool is_ready &#x3D; true;</span><br></pre></td></tr></table></figure></p>
<h2 id="const-限定符">1.2. const 限定符</h2><p>如果程序在多个地方使用相同的一个<strong>常量</strong>时，可用<code>const</code>来修改变量声明和初始化。<br>例如，表示一年中月份的符号常量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int Months &#x3D; 12;</span><br></pre></td></tr></table></figure><br><code>常量Months</code>被初始化后，其值就被固定了，编译器将不允许再修改该常量的值。</p>
<p>一种常见的做法是<code>常量的首字母大写</code>如<strong>Months</strong>，有助于区分<strong>常量</strong>和<strong>变量</strong>。另外一种做法是<code>以字母k打头</code>如<strong>kmonths</strong></p>
<h2 id="浮点数">1.3. 浮点数</h2><p>C++有3种浮点类型：float，double和long double。</p>
<p>浮点数能够表示带小数部分的数字，诸如2.5，3.14159，122442.32这样的数字。</p>
<p><strong>计算机</strong>将这样的值分成两部分存储。<code>一部分表示值，另一部分用于对值进行放大或缩小。</code></p>
<p>打个比方，对于数字34.1245和34124.5，他们除了小数点位置不同，其他事相同的。</p>
<p>可以把第一个数表示为0.341245（基准值）和100（缩放因子）；第二个数0.341245（基准值）和10000（缩放因子）。</p>
<p><code>缩放因子</code>的作用是移动小数点的位置，术语<code>浮点</code>也因此得名。</p>
<p><strong>C++</strong>内部表示浮点数的方法与此相同，只不过它基于的是二进制数，因此缩放因子是2的幂，不是10的幂。</p>
<h3 id="浮点数的表示法">1.3.1. 浮点数的表示法</h3><ul>
<li><strong>第一种</strong> 是使用常用的标准小数点表示法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12.34</span><br><span class="line">0.00023</span><br><span class="line">8.0 &#x2F;&#x2F; 保证了是float而非int</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>第二种</strong> 是使用E表示法<br>其外观类似3.45E6，意思是3.45与1000000相乘的结果；E6指的是10的6次方。<br>E表示法确定数字以浮点格式存储，即使没有小数点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.52e+8 &#x2F;&#x2F; valid</span><br><span class="line">8.33E5 &#x2F;&#x2F; valid</span><br><span class="line">8.33E-4 &#x2F;&#x2F; valid, exponent can be negative</span><br></pre></td></tr></table></figure>
<h3 id="浮点的类型float，double和long-double">1.3.2. 浮点的类型float，double和long double</h3><p>浮点数的三种类型是按<code>它们可以表示的有效数位和允许的指数最小范围</code>来描述的。</p>
<p><strong>有效位(significant figure)</strong>是指数字中有意义的位，</p>
<p>🍑 例如：</p>
<p>某山脉额高度位14179英尺，该数字使用了5个有效位。</p>
<p>然而，将其高度写成约14000英尺时，其有效数位为2。因为结果进行了四舍五入精确到了千位。这种情况下，其余的3位仅仅为占位符。</p>
<p>有效数位不依赖于小数点的位置。</p>
<p>例如，可以将山脉高度写为14.162千英尺，这样仍然是5个有效位。</p>
<hr>
<p>C++对于有效位数的要求是：</p>
<ul>
<li>float 至少32位</li>
<li>double至少48位，且不少月float</li>
<li>long double至少和double一样多</li>
</ul>
<p>但通常：</p>
<ul>
<li>float为32位</li>
<li>double为64位</li>
<li>long double为80，96或128位</li>
</ul>
<p>书本p48页提供了一个例子说明了double比float提供的精度更高。</p>
<figure class="highlight plain"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std; </span><br><span class="line">    cout.setf(ios_base::fixed, ios_base::floatfield); &#x2F;&#x2F; fixed-point</span><br><span class="line">    float tub &#x3D; 10.0 &#x2F; 3.0;     &#x2F;&#x2F; good to about 6 places</span><br><span class="line">    double mint &#x3D; 10.0 &#x2F; 3.0;   &#x2F;&#x2F; good to about 15 places</span><br><span class="line">    const float million &#x3D; 1.0e6;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;tub &#x3D; &quot; &lt;&lt; tub;</span><br><span class="line">    cout &lt;&lt; &quot;, a million tubs &#x3D; &quot; &lt;&lt; million * tub;</span><br><span class="line">    cout &lt;&lt; &quot;,\nand ten million tubs &#x3D; &quot;;</span><br><span class="line">    cout &lt;&lt; 10 * million * tub &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;mint &#x3D; &quot; &lt;&lt; mint &lt;&lt; &quot; and a million mints &#x3D; &quot;;</span><br><span class="line">    cout &lt;&lt; million * mint &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; cin.get();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点常量">1.3.2.1. 浮点常量</h4><p>在程序中书写副电厂粮食，像8.24或2.4E8这样的浮点都属于double类型。</p>
<p>如果你希望常量为float类型，请使用f或F后缀。</p>
<p>如果你希望常量为long double类型，可使用l或L后缀（由于l看起来很像数字1，因此L位更好的选择）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.234f &#x2F;&#x2F; a float constsant</span><br><span class="line">2.3423 &#x2F;&#x2F; a double constant</span><br><span class="line">2.2L &#x2F;&#x2F; a long double constant</span><br></pre></td></tr></table></figure>
<h4 id="浮点和整数的对比">1.3.2.2. 浮点和整数的对比</h4><ul>
<li>浮点优点：浮点可以表示整数</li>
<li>浮点优点：由于有缩放因子，他们可以表示的范围大的多</li>
<li>浮点缺点：浮点运算速度比整数运算速度慢，其精度降低</li>
</ul>
]]></content>
      <categories>
        <category>C++学习</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo搭建相关问题</title>
    <url>/2021/02/25/Hexo%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%982/</url>
    <content><![CDATA[<h2 id="一、文章创建和发布问题">0.1. 一、文章创建和发布问题</h2><h3 id="常用命令">0.1.1. 常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g 【生成静态文件】</span><br><span class="line">$ hexo d 【部署到网站或服务器，部署之前需要先生成静态文件】</span><br><span class="line">$ hexo clean 【清除缓存文件(db.json)和已经生成的静态文件(public)】</span><br></pre></td></tr></table></figure>
<h3 id="创建一个新的发布-Create-a-new-Post">0.1.2. 创建一个新的发布 Create a new Post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My new post&quot;</span></span><br></pre></td></tr></table></figure>
<p>更多信息 More info<a href="https://hexo.io/docs/writing.html">writing</a></p>
<h3 id="运行服务器-Run-server">0.1.3. 运行服务器 Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>更多信息 More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成统计文件-Generate-static-files">0.1.4. 生成统计文件 Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>更多信息 More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="部署到远程站点-Deploy-to-remote-sites">0.1.5. 部署到远程站点 Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>更多信息 More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h2 id="二、文章编辑问题">0.2. 二、文章编辑问题</h2><h3 id="显示不出分类、标签问题">0.2.1. 显示不出分类、标签问题</h3><h4 id="1-查看themes-next-config-yml主题配置文件">0.2.1.1. 1.查看themes/next/_config.yml主题配置文件</h4><img src="/2021/02/25/Hexo%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%982/menu.png" class title="This is an example image">
<p>打开主题配置文件<code>_config.yml</code>，在vim编辑器内用<code>/</code>搜索<code>menu</code>，确定categories和tags是取消注释状态的</p>
<h4 id="2-添加分类模块">0.2.1.2. 2.添加分类模块</h4><p>在主文件夹<code>Blog</code>页面下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><br>在source文件夹现在有了<code>categories/index.md</code>和<code>tags/index.md</code>两个新文件<br><img src="/2021/02/25/Hexo%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%982/categories.png" class title="This is an example image"><br>以<code>categories/index.md</code>为例子,应该自行添加第二行:<br><code>type: categories</code><br>注意:和categories中有一个空格</p>
<h4 id="3-文章中添加标签或分类的方法及效果">0.2.1.3. 3.文章中添加标签或分类的方法及效果</h4><p>在创建新文章后的顶端添加categories或tags的名字，注意空格<br><img src="/2021/02/25/Hexo%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%982/test.png" class title="This is an example image"></p>
<p>最后的效果:<br><img src="/2021/02/25/Hexo%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%982/show.png" class title="This is an example image"></p>
<h4 id="4-参考">0.2.1.4. 4.参考</h4><p><a href="https://blog.csdn.net/Wonz5130/article/details/84666519">Hexo搭建博客显示不出分类、标签问题</a></p>
<h3 id="Hexo博客搭建之在文章中插入图片">0.2.2. Hexo博客搭建之在文章中插入图片</h3><h4 id="1-本地引用">0.2.2.1. 1.本地引用</h4><p>当中只用到少量图片时，可以将图片统一放在<code>source/images</code>文件夹中，通过markdown语法添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ![](&#x2F;images&#x2F;image.png)</span><br></pre></td></tr></table></figure></p>
<h4 id="2-相对路径">0.2.2.2. 2.相对路径</h4><p>图片可以放在文章自己的目录中，需要先配置<code>_config.yml</code>文件，将<code>post_asset_folder</code>设置为true。设置完之后，在执行<code>hexo new &quot;post_name&quot;</code> 这个操作后，在<code>source/_posts</code>中会自动生成<code>post_name.md</code>和<code>post_name</code>同名文件夹。这时候只需要将图片放在<code>post_name</code>文件夹中，文章中可以直接使用相对路径引用了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ![](image.png)</span><br></pre></td></tr></table></figure>
<p>但是!!重点来了，这个经典的markdown语句只能保证文章中可以显示出图片，但首页上不限时，很丑。可以同时显示的语句是:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ &#123;% asset_img exemple.png This is an example image %&#125;</span><br></pre></td></tr></table></figure><br>这时候就大功告成啦！</p>
<h4 id="3-云引用">0.2.2.3. 3.云引用</h4><p>比如一些免费的CDN服务，如Cloudinary等免费生成的url地址，直接用markdown语法引用即可。</p>
<h4 id="4-参考-1">0.2.2.4. 4.参考</h4><p><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a></p>
]]></content>
      <categories>
        <category>网页</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>cv</title>
    <url>/2021/04/09/cv/</url>
    <content><![CDATA[<img src="/2021/04/09/cv/FR_yujiaYANG.jpg" class>
]]></content>
  </entry>
  <entry>
    <title>Toeic备考记录</title>
    <url>/2021/05/02/Toeic%E5%A4%87%E8%80%83%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="碎碎念">0.0.1. 碎碎念</h3><p>近日本来想赶着回国前把托业考下来，结果机票熔断了，这就是后话了…</p>
<p>匆忙的报了4.30号的托业，加上super express correction一共170欧，考点在93区的centrex。</p>
<p><a href="https://www.etsglobal.org/fr/fr/session/search/ile-de-france/paris?testTypeIds[]=100291&amp;date=2021-05-02&amp;showMap=false">报名地址查询</a></p>
<p>找工作的时候一直没有一个上得了台面的英语成绩，多年前裸考的雅思5.5写了还不如不写QAQ</p>
<p>当天13点考完，16点多成绩就发到邮件了，速度超快 930/990，也大于国内六级了，终于有一个普通人都有的英语成绩可以写在cv上了QAQ</p>

<h3 id="备考真题的网站">0.0.2. 备考真题的网站</h3><p><a href="https://www.bilibili.com/video/BV1fh411S7VH/">2021最新托业全套练习</a></p>
<p><a href="https://www.bilibili.com/video/BV1qo4y1d7xW/">2021托业听力练习含答案</a></p>
<p><a href="https://www.ets.org/s/toeic/pdf/toeic-listening-reading-sample-test-updated.pdf">sample test</a></p>
<p><a href="https://global-exam.com/blog/zh/toeic-score-conversion-table/#:~:text=%E5%A6%82%E4%BD%95%E8%A8%88%E7%AE%97%E5%88%86%E6%95%B8%EF%BC%9F,%E5%89%87%E5%B0%87%E7%8D%B2%E5%BE%97495%E5%88%86%E3%80%82">Toeic分数换算表</a></p>
<p><a href="https://github.com/odcowl/Codes_for_blog/blob/master/toeic/109.pdf">托业的语法句型题目pdf</a></p>
<div class="pdfobject-container" data-target="https://cdn.jsdelivr.net/gh/odcowl/Codes_for_blog/blob/master/toeic/109.pdf" data-height="500px"></div>
<p>希望下一步还是可以拿下雅思/托福这种被大众更承认的成绩QAQ</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>向Hexo博客插入Jupyter Notebook的办法</title>
    <url>/2021/03/12/%E5%90%91Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5Jupyter-Notebook%E7%9A%84%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>如何把jupyter放在hexo博客中<a href="https://github.com/qiliux/hexo-jupyter-notebook">链接</a><br>向 Hexo 博客中插入 Jupyter Notebook <a href="https://blog.csdn.net/The_last_knight/article/details/109391184">链接</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>我的vim编辑器cheat sheet</title>
    <url>/2021/02/26/%E6%88%91%E7%9A%84vim%E7%BC%96%E8%BE%91%E5%99%A8cheat-sheet/</url>
    <content><![CDATA[<p>比较喜欢vim编辑器的极简化，所以慢慢整理了一些自己常用的命令</p>
<h4 id="移动光标">0.0.0.1. 移动光标</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>k-j-h-l</td>
<td>代表上-下-左-右</td>
</tr>
<tr>
<td>数字0</td>
<td>回到本行开头</td>
</tr>
<tr>
<td>$</td>
<td>回到本行结尾</td>
</tr>
<tr>
<td>w</td>
<td>移到下一单词或标点的开头</td>
</tr>
<tr>
<td>W</td>
<td>移到下一单词的开头,忽略标点</td>
</tr>
<tr>
<td>b</td>
<td>移到上一单词或标点的开头</td>
</tr>
<tr>
<td>B</td>
<td>移到上一单词的开头,忽略标点</td>
</tr>
<tr>
<td>nG</td>
<td>移到第n行,注意G也是大写</td>
</tr>
<tr>
<td>:n + enter键</td>
<td>移到第n行</td>
</tr>
<tr>
<td>G</td>
<td>移到光标最后一行</td>
</tr>
<tr>
<td>H</td>
<td>移到当前屏幕的第一行</td>
</tr>
<tr>
<td>L</td>
<td>移到当前屏幕的最后一行</td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>短时傅里叶变换STFT及Python/Matlab实现</title>
    <url>/2021/03/10/%E5%A3%B0%E5%AD%A6%E5%8F%82%E6%95%B0-%E7%9F%AD%E6%97%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2STFT/</url>
    <content><![CDATA[<p>一天一个<strong>声学参数</strong>之短时傅里叶变换STFT及其Python和Matlab的实现，在C++稍微上手一点儿后来补充C++的版本。</p>
<h3 id="1-原理">0.0.1. 1. 原理</h3><p>短时傅里叶变换(Short Time Fourier Transform, STFT)是一个用于语音信号处理的通用工具(时频分析方法）。短时傅立叶变化的过程是<strong>把一个较长的时间信号分成相同长度的更短的段落，在每个更短的段上计算傅立叶变换</strong>。</p>
<p>在实现时，短时傅里叶变换的计算实际上是一系列加窗数字信号的快速傅里叶变换(Fast Fourier Transform, FFT)，其中窗口随时间”滑动Slide“或”跳跃Hop”。</p>
<h4 id="为什么要用STFT">0.0.1.1. 为什么要用STFT</h4><p>短时傅里叶变换主要用于分析<strong>非平稳信号</strong>。非平稳信号由于波形的变化没有规律，也没有<strong>瞬间频率</strong>的概念，不能直接使用快速傅里叶变换。<strong>加窗</strong>使信号平稳化（从时间上截断，使得短时间内波形没有显著变化），于是可以对加窗的分段信号一段一段的使用FFT。也可以说，STFT得到的是按时间顺序排列的n段信号的频谱。</p>
<h4 id="STFT的频率分辨率和时间分辨率">0.0.1.2. STFT的频率分辨率和时间分辨率</h4><p>在短时傅里叶变化过程中，窗的长度决定频谱图的时间分辨率和频率分辨率，窗长越长，截取的信号越长，频率分辨率越高，时间分辨率越差。在STFT中，时间分辨率和频率分辨率不可兼得，应该按照具体需求取舍。<strong>换句话说</strong>，窄窗口时间分辨率高、频率分辨率低，宽窗口时间分辨率低、频率分辨率高。对于时变的非稳态信号，高频适合小窗口，低频适合大窗口。</p>
<h4 id="STFT的物理和数学公式">0.0.1.3. STFT的物理和数学公式</h4><p>短时傅里叶变换过程：将信号与一个窗函数想成，再进行一维的傅里叶变换。并通过窗函数的滑动得到一系列变化结果。</p>
<p>公式：<br><img src="/2021/03/10/%E5%A3%B0%E5%AD%A6%E5%8F%82%E6%95%B0-%E7%9F%AD%E6%97%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2STFT/STFT1.png" class></p>
<p>其中，<code>z(t)</code>为原信号函数，<code>g(t)</code>为窗函数。</p>
<p>为了方便计算机处理，一般将信号离散化： <code>z(t) =&gt; z(n)</code>:</p>
<img src="/2021/03/10/%E5%A3%B0%E5%AD%A6%E5%8F%82%E6%95%B0-%E7%9F%AD%E6%97%B6%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2STFT/STFT2.png" class>
<h3 id="STFT的编程实现过程">0.0.2. STFT的编程实现过程</h3><h4 id="基于Matlab的实现过程（未验证）">0.0.2.1. 基于Matlab的实现过程（未验证）</h4><ul>
<li>第一步：确定相关参数</li>
</ul>
<p><strong>参数主要包括</strong>：原信号，窗函数类型，窗长，重叠点数，采样频率，傅里叶点数等</p>
<p>其中，傅里叶点数主要用在傅里叶变化过程中，当信号长度小于傅里叶点数时，系统会自动进行补零，然后再进行快速傅里叶变换（FFT）。</p>
<ul>
<li>第二步：计算窗滑动的次数</li>
</ul>
<p>计算<code>信号的长度nx</code>，并根据<code>信号长度nx</code>、<code>窗长WinLen</code>以及<code>窗口之间的重叠点数OverLap</code>计算出需要<code>窗口滑动的次数n</code>。同时，也是源信号分成多少个短信号的列数。</p>
<script type="math/tex; mode=display">\pi</script><p>n = fix((nx-overlap)/(WinLen-overlap))<br>(fix是matlab里的取整函数)</p>
<ul>
<li>第三步：确定每一列的值，得到一个<code>列数为n，行数为WinLen的矩阵Fig</code></li>
</ul>
<p>unknown block tag: asset_jupyter’col_index = (0:(t-1))*(WinLen-noverlap)<br>rowindex = (1:WinLen)’</p>
<p>xin = zeros(frame_length,t);<br>xin(:) = x(rowindex(:,ones(1,t))+colindex(ones(WinLen,1),:）);</p>
<ul>
<li>第四步：把转换为列向量的窗函数扩展为n列的矩阵w，并对矩阵Fig和w进行点乘，并对点乘的结果进行快速傅里叶变换，得到时频矩阵。</li>
</ul>
<p>xin = win(:,ones(1,t)).*xin;</p>
<ul>
<li>第五步：根据时频矩阵，输出频谱图</li>
</ul>
<p>以上参考<a href="https://blog.csdn.net/zhaoyinhui0802/article/details/53048362">短时傅里叶变化原理解</a></p>
<h4 id="基于Python的实现过程">0.0.2.2. 基于Python的实现过程</h4><p>在程序中，<code>frame\_size</code>是被分成较短信号的帧的大小。在语音处理中，帧大小通常在20-40ms，这里设置25ms，即frame_size=0.025.</p>
<p><code>frame_stride</code>为相邻帧的滑动尺寸/跳跃尺寸，通常帧的滑动尺寸在10ms到20ms之间，这里设置初始化为10ms，即frame_stride=0.01，此刻，相邻帧的<code>交叠大小</code>为15ms。</p>
<p>窗函数采用<code>汉明窗函数(Hamming Function)</code>。</p>
<p>在每一帧，进行512点的快速傅里叶变换，即<code>NFFT=512</code> </p>
<p>以上参考<a href="https://www.cnblogs.com/klchang/p/9280509.html">短时傅里叶变换(Short Time Fourier Transform)原理及 Python 实现</a></p>
<h4 id="Python实现STFT代码-三种方法">0.0.2.3. Python实现STFT代码 三种方法</h4><iframe src="https://nbviewer.jupyter.org/github/odcowl/Codes_for_blog/blob/master/%E5%A3%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E7%A7%AF%E7%B4%AF/STFT_local3.ipynb" width="100%" height="600"></iframe>
]]></content>
      <categories>
        <category>声学参数</category>
      </categories>
  </entry>
  <entry>
    <title>法语花卉词汇</title>
    <url>/2021/02/27/%E6%B3%95%E8%AF%AD%E8%8A%B1%E5%8D%89%E8%AF%8D%E6%B1%87/</url>
    <content><![CDATA[<h2 id="Les-fleurs-en-francais">0.1. Les fleurs en français</h2><p><strong>mimosa n.m 含羞草</strong></p>
<img src="/2021/02/27/%E6%B3%95%E8%AF%AD%E8%8A%B1%E5%8D%89%E8%AF%8D%E6%B1%87/13292-mimosa-dhiver-le-gaulois-6.jpeg" class title="This is an example image">
<p>含羞草（Mimosa pudica）是一种不寻常的植物，因为它通过折叠叶子来响应触摸。出于这个原因，它通常也被称为敏感植物。好奇的猫可能喜欢在这种植物的叶子上击球，因为它会响应他们俏皮的姿势。幸运的是，根据康涅狄格大学农业与自然资源学院的说法，如果你的猫决定蚕食一两片叶子，他就不会受到伤害：这种植物没有毒性。</p>
<p><em>Le langage des fleurs</em></p>
<blockquote>
<p>Jaune lumière, le mimosa est riche de significations : on le compare naturellement au soleil. Il symbolise également la magnificence, l’élégance, la tendresse et délivre un message d’amitié.</p>
<p>含羞草淡淡的黄色，有着丰富的含义：我们它与太阳相比较。它象征着华丽，优雅，温柔并传递着友谊的信息。</p>
</blockquote>
<hr>
<p><strong>tulipe n.f 郁金香</strong></p>
<img src="/2021/02/27/%E6%B3%95%E8%AF%AD%E8%8A%B1%E5%8D%89%E8%AF%8D%E6%B1%87/tulipe-135728.jpg" class>
<p>郁金香，百合科郁金香属的多年草本植物，花期是4-5月。</p>
<p>郁金香对猫咪有毒，临床症状为呕吐，抑郁，腹泻，过度分泌唾液。球茎中毒素浓度最高。</p>
<p><em>Le dangage des fleurs 花语</em></p>
<blockquote>
<p>Dans le langage des fleurs, la tulipe symbolise d’une manière générale l’amour, mais avec des nuances qui varient selon sa couleur. Pourpre, elle incarne la royauté. Blanche, elle demande le pardon.<br>在郁金香的花语中，它一般象征着爱情，但因其颜色不同还有细微差别。比如紫色，代表着皇家气派；而纯白，则是为了表达歉意，请求原谅。</p>
</blockquote>
]]></content>
      <categories>
        <category>法语学习</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记 杏仁</title>
    <url>/2021/04/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9D%8F%E4%BB%81/</url>
    <content><![CDATA[<img src="/2021/04/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9D%8F%E4%BB%81/fengmian.jpeg" class>
<p>《杏仁》是韩国作家孙元平所著的第一篇长篇小说作品。全文分为四大章节，75个小节，讲述了一名少年“自救”和“被救”的故事。</p>
<p>看到这本书是因为张哲瀚的ins的分享哈哈哈哈。但是看完之后还是打算按自己的预想，在博客中记录下来。</p>
<blockquote>
<p>一个光靠自己的力量什么也做不了的小生命，就这样被带到这个世界，冲着天空挣扎着。</p>
</blockquote>
<p>文中的‘我’，是一个杏仁体核小，即述情障碍患者的小男孩。也就是说，他感受不到别人的情绪，对开心、难过、喜欢等情绪都很模糊。所以他也被所有人称为小怪物。</p>
<blockquote>
<p>因为你很特别。人啊，本来就不能忍受跟自己不一样的食物。哎呀，我们家这可爱的怪物。</p>
</blockquote>
<p>在全文中，我最喜欢的角色就是外婆。她对妈妈，对“我”所有无条件的爱，她如一只雄鹰护着自己的幼崽，也直到最后一刻。妈妈在我看来也是需要被救赎的（最后苏醒的原因），沈医生的好又是另外一种好，坤是互相救赎的存在。</p>
<blockquote>
<p>书能马上带我到我去不了的地方，让我听见我遇不到的人的告白，看到我观察不到的那些人的人生。我感受不到的情绪、没遇到的食物，都被秘密地收录其中。</p>
<p>电影、电视剧还有漫画里的世界都太过具体，没有我能参与的空间。</p>
</blockquote>
<p>因为我自己也更喜欢各种类型的书，而看电视剧或电影的时候会有被迫接受的感觉，如果是已经看过书再开改编的剧会更有这种感觉。</p>
<p>文中的妈妈在小巷子里开的小书店，有时候外婆说她嫁错了对象，丈夫配不上她，但这样一个浪漫的女人是不在乎所谓配不配得上的。也正是因为她特有的品质，才会遇到如沈医生一般的人吧。</p>
<blockquote>
<p>以后除了我，再也没有任何人会记得她们的人生，所以，我要活下去。</p>
</blockquote>
<p>在全文四分之一初，’我’的自白，证明我并不是全无情绪。</p>
<p>在这时，妈妈和外婆为了救我，在开心的吃完一碗并不怎么好吃的面条后，牺牲了。这样的小市民，又有多少人能惦记着呢？葬礼的现场与后面坤母亲的葬礼也是鲜明的对比。这里看得我很压抑，坤的母亲在死亡之前，其实就被坤的父亲从心中删去了。这样的活着还有什么意义。人离开后，有多少人曾用心的记着你？生怕忘记你？</p>
<p>从此以后，坤出场了。</p>
<blockquote>
<p>每次想到妻子时，脑海中就会浮现香喷喷的面包。他的妻子总是亲自为他烤面包，那个味道让他回想起一些旧事，比如已经遗忘的童年记忆。</p>
</blockquote>
<p>当提到这样自己的记忆，我脑海中总是浮现自己作为接受者的时刻。不知道有一日是否别人的记忆里也会浮现我。</p>
<blockquote>
<p>书店是个成千上万名作家笔下无数活着的死去的任务高度密集的地区。</p>
</blockquote>
<p>所以书店是听不见却吵吵嚷嚷的地方，会不会有好事的图书管理员，把两位仇人的作品刚好摆放在一起？</p>
<p>文中的第三第四部分，我翻过了自己的笔记，没有留下让我印象深刻的语句。这两段主要讲述的是和坤及度萝的故事。</p>
<p>可能全文最让我动容部分居然不是与坤的互相救赎（当然这一段应该才是作者想写的重点部分），但是我更喜欢的还是全文最开头外婆与妈妈和我的相处部分。沈医生我也很喜欢，像激荡的大海里一艘不会翻倒的中型船只。</p>
<p>文章的末尾作者写道：</p>
<blockquote>
<p>从平淡的成长过程中我发现，我所得到的那些帮助与爱，还有无条件的支持是多么稀有且珍贵。那对一个人而言是多么强大的武器，又能带给他多少力量，让他能无惧地接触这个世界， 这些都是我为人父母后才体会到的。</p>
</blockquote>
<p>看到结尾，猜测作者用沈医生来代表了自己吧？</p>
<p>但是，我万分同意，无条件的支持对孩子来说有多么珍贵。所曾懊悔的，不曾得到的。</p>
<blockquote>
<p>希望借由这本小说，能有更多的人伸出援手，帮助那些受伤的人和尚存希望的孩子。</p>
</blockquote>
<p>这本书就记录到这里了，耗时2天读完。</p>
<p>2021.4.21 于巴黎</p>
]]></content>
      <categories>
        <category>2021读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记 湖泊by东野圭吾</title>
    <url>/2021/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B9%96%E6%B3%8Aby%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/</url>
    <content><![CDATA[<img src="/2021/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B9%96%E6%B3%8Aby%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/fengmian.jpeg" class>
<blockquote>
<p>尸体要在湖底消失需要好几年，不，大概要花好几十年吧。这中间我们肯定都会提心吊胆的。就算尸体不见了，我们的灵魂也无法离开这湖畔吧。</p>
</blockquote>
<p>很搞笑的一件事是，我是从凌晨2点开始阅读这本书的，在5点前阅读完，期间伴随着窗对面法国年轻人soirée的欢呼声和音乐声。这一帮聚会的人，平时我肯定辗转难眠骂骂咧咧，这次却让我没有在读书的时候背脊发凉…</p>
<p>早就听闻东野圭吾的小说很精彩，这次果然感受到了其小说的魅力！</p>
<p>诸多的犯罪和真相细节在专业的文评里可以找到，博客里我只想简单记录每次阅读后的感悟和心情。</p>
<blockquote>
<p>尸体要在湖底消失需要好几年，不，大概要花好几十年吧。这中间我们肯定都会提心吊胆的。就算尸体不见了，我们的灵魂也无法离开这湖畔吧。</p>
</blockquote>
<p>小时候不懂得谎言的代价，用谎言换取奖励，用谎言逃避责罚。谎言的层次感也是长大后才明白，何为善意的谎言，何为恶意的谎言。</p>
<p>但每当不真诚的话说出口，总会担心着需要怎么把谎言说的更真，更让听者信服，不知不觉的又加重了语言上的负担感。久而久之，宁愿不去编造所谓的善意谎言，也不想说出不真诚的话。</p>
<p>一个谎言需要千千万万个谎言来圆谎。</p>
<blockquote>
<p>你是说有的母亲为了招待老师，不惜牺牲自己的肉体吗？</p>
</blockquote>
<p>读到这里心中最是沉重。千千万万的亚洲家长们（大部分的情况），为了孩子的学业，没有自己的生活，一掷千金还算好的，需要出卖自己的灵魂去谄媚，甚至出卖自己的肉体。</p>
<p>但我一直觉得很奇怪的是，真的会有人如此“饥渴”？</p>
<p>总而言之，坐在某种握着某种权利的位置上，再处于某种社会环境中，人就会变。</p>
<p>可怜天下父母心。</p>
<blockquote>
<p>“嗯，回去的时候，你会跟我和妈妈一起吧？不是各走各路的吧？“ 章太。</p>
</blockquote>
<p>孩子的内心需要保护，看起来再冷漠顽固的小孩子，心里的渴望或许就那么简单。</p>
<p>每个人心里都有那个自己认为的凶手，作者也似乎刻意给每个小孩子安排了合适的动机。悬疑未解，但已经不重要了。</p>
<p>父母的结合究竟对孩子有那么重要吗？其实我觉得并不是。父母如果能做到互相关心、爱护，那一定是最完美的家庭，但假如不呢？</p>
<p>我认为最重要的是父母之间的互相尊重，而不是单独在孩子面前指责不在场的另一半。</p>
<p>对于孩子来说，从小就要面临站哪一边的选择。</p>
<p>在俊介来到别墅前，美菜子跟所有人吐槽俊介的行为，章太也是看在眼里吧。即便不是血亲，父亲依然是章太的心里另一半天，作为母亲不应该试图把这一片天抹黑。</p>
<p>与其互相的指责，不如坐下来心平气和的告诉孩子：我们的爱情或许结束了，但我们还可以拥有亲情。</p>
<p>小孩子根本不懂得爱的差别，只有大人才斤斤计较。</p>
<p>——————</p>
<p>接下来还想阅读东野圭吾的其他作品。</p>
<p>2021.05.23</p>
]]></content>
      <categories>
        <category>2021读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记 白夜行by东野圭吾</title>
    <url>/2021/05/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%99%BD%E5%A4%9C%E8%A1%8Cby%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/</url>
    <content><![CDATA[<img src="/2021/05/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%99%BD%E5%A4%9C%E8%A1%8Cby%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/fengmian.jpeg" class>
<p>继续读闲书…</p>
<p>上次读完湖泊后，对日本悬疑类小说名家东野圭吾的作品继续产生兴趣，于是就读了这本《白夜行》。</p>
<p>先说结尾，我还是不太习惯于戛然而止式的结尾😅总觉得坏人应该得到无论是法律上还是心灵上的惩罚，好人应该有好的结局。</p>
<p>亮跳下去后背过身的雪穗是真的有失控吗？</p>
<p>R&amp;Y的未来如何？</p>
<p>警官是否心满意足的找到了真正的罪犯？</p>
<p>也有可能这大片的留白是作者留下的想象空间，只可惜我这种凡人想象不到罢了。</p>
<hr>
<p>故事开始于大人的罪恶，小孩子无法选择的命运。</p>
<p>恶之花在废弃的大楼里流着泪生长，压抑又复杂的小孩子间惺惺相惜、共生的情感，最终造就了所有阳光下的罪恶。</p>
<blockquote>
<p> 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</p>
</blockquote>
<p>我觉得亮心里有一丝愧疚，他认为是自己的责任要去守护雪穗。</p>
<p>这是一种复杂的情感。自己的父亲是变态，自己喜爱的女生惨遭毒手。所以他要成为代替太阳的守护者，他要保护心里的花朵，即便这朵花早已变质。</p>
<blockquote>
<p>只希望能手牵手在太阳下散步</p>
</blockquote>
<p>对于我来说，这早就不是雪穗的想法。</p>
<p>一个人越来越靠近阳光，一个人只能向蝼蚁般藏匿地下。</p>
<blockquote>
<p>美佳差点惊呼失声，雪穗伸出食指抵住她的唇。</p>
<p>“那时，我比现在的你更小，真的还是孩子。但是，恶魔不会因为你是孩子就放过你。而且，恶魔还不止一个。”</p>
<p>“不……”美佳喃喃地说，却发不出声音。</p>
<p>“现在的你，就是那时的我。”雪穗压在美佳身上，双手抱住美佳的头，“真可怜。 »</p>
</blockquote>
<p>应该是全文里我看的最有生理性反感的部分吧。</p>
<p>因为曾经见过黑暗，所以要把所有美好的人脱向黑暗。</p>
<p>所有和雪穗有关系的人最后都没有落得好的结局，而这些人都很善良。</p>
<blockquote>
<p>雪穗像人偶般面无表情。她冰冷地回答：“我不知道。雇用临时工都由店长全权负责。 </p>
</blockquote>
<p>最终亮带着那把杀死父亲的小剪刀，一跃而下。</p>
<p>在大阪店的开业典礼上，所有的纸醉金迷，截然而止。</p>
<p>我不由地问，笹垣真的可以捉拿雪穗吗？</p>
<p>为什么要给这样子的人留下一条生路了？这大概是我还没有读懂作者的一点。</p>
<hr>
<p>打算停下来阅读悬疑类别的小说，准备准备刷题啦❤️</p>
<ul>
<li>想要自救</li>
</ul>
]]></content>
      <categories>
        <category>2021读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>我的读书笔记-非暴力沟通</title>
    <url>/2021/05/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
    <content><![CDATA[<img src="/2021/05/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/fengmian.jpeg" class>
<p>一些摘录:</p>
<p><strong>非暴力沟通的过程</strong></p>
<blockquote>
<ul>
<li><p>什么是我的观察</p>
</li>
<li><p>我的感受如何</p>
</li>
<li><p>那些需要（或价值、愿望等）导致那样的感受</p>
</li>
<li><p>为了改善，我的具体请求</p>
</li>
</ul>
<p>举个例子，一个母亲可能对她处于青春期的儿子说：”菲利克斯，看到咖啡桌下的两&gt;  只脏袜子和电视机旁的第三只，我不太高兴，因为我看重整洁，你是否愿意将袜子拿到  房间或放进洗衣机？“</p>
<p>语言使我们陷入是非之中。它擅长将人分类，把人看做好人或坏人，正常或不正常，  负责人或不负责任，聪明或愚蠢，等等。</p>
</blockquote>
<p>有一些语言是”貌似客观”的，对他人的评价反应的是我们主观的需要和价值观。</p>
<blockquote>
<p>我们不要将价值判断与道德评判混为一谈。什么是可贵的品质，我们每个人都有自己的看法。</p>
<p>不带评论的观察是人类智力的最高形式。——印度哲学家 克里希那穆提</p>
<p>如果我们的表达言过其实，别人就可能产生逆反心理，而不愿作出友善的回应。</p>
</blockquote>
<p><strong>听到不中听的话时</strong></p>
<blockquote>
<p>听到不中听的话时，我们有四种选择：</p>
<ul>
<li>第一种是认为自己犯了错。这会导致我们内疚、惭愧，甚至厌恶自己</li>
<li>第二种是指责对方</li>
<li>第三种是了解我们内心的感受和需要</li>
<li>第四种是用心体会他人的感受和需要</li>
</ul>
<p>如果我们想利用他人的内疚，我们通常采取的方法是把自己不愉快的感觉归咎于对方。</p>
<p>批评往往暗含着期待。对他人的批评实际上间接表达了我们尚未满足的需要。</p>
<p>如果我们通过批评来提出主张，人们的反应常常是申辩或反击。反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。</p>
</blockquote>
<p><strong>女性的角色</strong></p>
<blockquote>
<p>对于妇女来说，社会文化并不鼓励我们表达个人需要。一旦把照顾他人当作最高职责，她们也就会倾向于忽视个人的需要。<br>在社会文化的影响下，许多妇女在表达请求时感到别扭，好像做错了什么。例如，她可能不会说：“我今天累坏了，晚上想休息。”相反，她的话听起来也许就像是辩护词：“你知道我一整天都没歇过，我熨了所有的衬衣，把这周的脏衣服都洗了，准备了午餐和晚餐，还出去买了东西…你是否可以…?“ </p>
<p>如果我们不看重自己的需要，别人可能也不会。</p>
</blockquote>
<p><strong>提出具体的请求</strong></p>
<blockquote>
<p>许多向我来求助的人后来发现，他们感到沮丧或灰心，很大程度上是因为他们不清楚自己对他人究竟有什么样的期待。</p>
</blockquote>
<p><strong>分清楚请求和命令</strong></p>
<blockquote>
<p>一旦人们认为不答应我们就会收到责罚，他们就会把我们的请求看作是命令。听到命令时，一个人只能看到两种选择：服从或反抗。不论如何，只要人们认为我们是在强迫他们，他们就不会乐于满足我们的需要。</p>
</blockquote>
]]></content>
      <categories>
        <category>2021读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>此文为<a href="https://leetcode-cn.com/leetbook/read/linked-list">链表</a>的学习笔记。</p>
<h1 id="概述">1. 概述</h1><p>与数组相似，链表也是一种<code>线性</code>的数据结构，下图为单链表的例子：<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-12-at-152754.png" class></p>
<p>链表中的每一个元素实际上是一个单独的对象，而对象之间的链接，则是每个元素中的引用字段构造的。</p>
<p>链表有两种类型：<code>单链表</code>和<code>双链表</code>，下图为双链表的例子：<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-17-at-161130.png" class></p>
<h1 id="单链表">2. 单链表</h1><p>单链表中的每个结点不仅包括<code>值</code>，还包括链接到下一个结点的<code>引用字段</code>。通过这种方式，单链表将所有结点按顺序组织起来。</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-12-at-152754.png" class>
<p>如上图中的蓝色箭头则为链接结点的组合方式。</p>
<p>在大多数情况下，我们将使用头结点（第一个结点）来表示整个列表。</p>
<h2 id="与数组的不同处">2.1. 与数组的不同处</h2><p>与数组不同，<strong>我们无法在常量时间内访问单链表中的随机元素</strong>。</p>
<p>如果我们想获得第i个元素，我们<strong>必须从头结点逐个遍历</strong>。我们按照<code>索引</code>来<code>访问元素</code>平均花费<code>O(N)</code>时间，其中N为链表的长度。</p>
<p>所以，在通过索引访问数据时（与数组相比），性能不好。但是在操作和删除操作时，有链表的好处。</p>
<h2 id="单链表的添加操作">2.2. 单链表的添加操作</h2><p>如果我们想在给定的结点prev之后添加新值，我们应该：</p>
<ul>
<li><p>使用给定值初始化新结点cur</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-25-at-163224.png" class>
</li>
<li><p>将cur的next字段链接到prev的下一结点next</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-25-at-163234.png" class>
</li>
<li><p>将prev中的next字段链接到cur</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-25-at-163243.png" class>
</li>
</ul>
<p>与<strong>数组</strong>不同，我们不需要将元素移动到插入元素后。所以，我们可以在<code>O(1)</code>的时间复杂度将新结点插入到链表中，十分高效。</p>
<h3 id="Python-实现（力扣自代的链表定义）">2.2.1. Python 实现（力扣自代的链表定义）</h3><h4 id="单链表添加">2.2.1.1. 单链表添加</h4><p>比如我们想在第二个结点6后插入一个新的值9。<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-12-at-152754.png" class></p>
<p>我们首先初始化一个值为9的新结点，将结点9链接到结点15，最后将结点6链接到结点9。<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-12-at-154238.png" class></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(head) </span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;</span></span><br><span class="line">cur = ListNode(9)</span><br><span class="line">cur.next = head.next.next</span><br><span class="line">head.next.next = cur</span><br><span class="line"><span class="comment"># print(head)</span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 9, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>插入后的链表：<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-12-at-154238.png" class></p>
<h4 id="单链表在开头添加结点">2.2.1.2. 单链表在开头添加结点</h4><p>在链表中，我们使用头结点来表示整个列表。</p>
<ul>
<li><p>初始化一个新结点cur</p>
</li>
<li><p>将新结点链接到我们的原始头结点</p>
</li>
<li><p>将cur指定为head</p>
</li>
</ul>
<p>例如，让我们在列表的开头添加一个新结点9。</p>
<ol>
<li>我们初始化一个新结点9并将其链接到当前头结点23。</li>
</ol>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-19-at-125118.png" class>
<ol>
<li>指定结点9为新的头结点。</li>
</ol>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-19-at-125350.png" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(head) </span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;</span></span><br><span class="line">cur = ListNode(9)</span><br><span class="line">cur.next = head</span><br><span class="line">head = cur</span><br><span class="line"><span class="comment"># print(head)</span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 9, next: ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="单链表在末尾添加结点">2.2.1.3. 单链表在末尾添加结点</h4><p>从<code>[23,6,15]</code>到<code>[23,6,15,9]</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(head) </span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;</span></span><br><span class="line">cur = ListNode(9)</span><br><span class="line">dum = head</span><br><span class="line"><span class="keyword">while</span> head.next:</span><br><span class="line">    head = head.next</span><br><span class="line">head.next = cur</span><br><span class="line">head = dum</span><br><span class="line"><span class="comment"># print(head)</span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: ListNode&#123;val: 9, next: None&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="单链表的删除操作">2.3. 单链表的删除操作</h2><h4 id="删除单链表中的一个结点">2.3.0.1. 删除单链表中的一个结点</h4><p>如果我们想从单链表中删除现有结点<code>cur</code>，可以分两步完成</p>
<ul>
<li>找到cur的上一个结点<code>prev</code>及其下一个结点<code>next</code>：</li>
</ul>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-26-at-203558.png" class>
<ul>
<li>接下来链接<code>prev</code>到cur的下一个节点<code>next</code></li>
</ul>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-26-at-203640.png" class>
<p>在第一步中，我们需要找出<code>prev</code>和<code>next</code>，使用<code>cur</code>的参考字段很容易找出next，但是我们必须从头结点遍历链表以找出<code>prev</code>，它的平均时间是<code>O(N)</code>，其中N是链表的长度。因此，删除结点的时间复杂度将是<code>O(N)</code>。</p>
<p>示例：</p>
<p>尝试把结点6从链表中删去：</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/screen-shot-2018-04-12-at-152754.png" class>
<ul>
<li><p>从头遍历链表，直到我们找到前一个结点<code>prev</code>即结点23</p>
</li>
<li><p>将<code>prev</code>（结点23）与<code>next</code>（结点15）链接</p>
</li>
</ul>

<p>另外一个更清晰的解释：</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/1613757478-NBOvjn-Picture1.png" class>
<p>参考：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/solution/mian-shi-ti-18-shan-chu-lian-biao-de-jie-dian-sh-2/">18.删除链表的节点</a></p>
<ul>
<li>特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。</li>
<li>初始化： pre = head , cur = head.next 。</li>
<li>定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。</li>
<li>保存当前节点索引，即 pre = cur 。</li>
<li>遍历下一节点，即 cur = cur.next 。</li>
<li>删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next ；若 cur 指向 nullnull ，代表链表中不包含值为 val 的节点。</li>
<li>返回值： 返回链表头部节点 head 即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(head)</span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;</span></span><br><span class="line"><span class="keyword">if</span> head.val == val:</span><br><span class="line">    <span class="built_in">return</span> head.next</span><br><span class="line">pre, cur = head, head.next</span><br><span class="line"><span class="keyword">while</span> cur and cur.val != val:</span><br><span class="line">    pre, cur = cur, cur.next</span><br><span class="line"><span class="keyword">if</span> cur:</span><br><span class="line">    pre.next = cur.next</span><br><span class="line"><span class="built_in">return</span> head</span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 15, next: None&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="删除链表头结点">2.3.0.2. 删除链表头结点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(head)</span></span><br><span class="line"><span class="comment"># ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;</span></span><br><span class="line"><span class="keyword">if</span> head.val == val:</span><br><span class="line">    <span class="built_in">return</span> head.next</span><br><span class="line"><span class="comment"># ListNode&#123;ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="删除最后一个结点">2.3.0.3. 删除最后一个结点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># head = ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: ListNode&#123;val: 15, next: None&#125;&#125;&#125;</span></span><br><span class="line">dummy = pre = head</span><br><span class="line"><span class="keyword">while</span> pre.next.next:</span><br><span class="line">    pre = pre.next</span><br><span class="line">pre.next = None</span><br><span class="line"><span class="built_in">return</span> dummy </span><br><span class="line"><span class="comment"># dummy = ListNode&#123;val: 23, next: ListNode&#123;val: 6, next: None&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="单链表中的快慢指针技巧">3. 单链表中的快慢指针技巧</h1><p>在<strong>链表</strong>题目中，有两种使用双指针的情景</p>
<ul>
<li>两个指针<code>从不同位置出发</code>：一个从始端开始，一个从末端开始</li>
<li>两个指针<code>以不同速度移动</code>：一个指针快些，一个指针慢些</li>
</ul>
<p>但对于单链表来说，我们只能在一个方向上遍历链表，所以第一种场景无法实现。第二种情况，也称为快慢指针，是非常有用的。</p>
<h2 id="题目1-环形链表">3.1. 题目1: 环形链表</h2><p>LeetCode原题<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141.环形链表</a></p>
<p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>进阶：<br>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p>示例1:<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/circularlinkedlist.png" class></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>示例2:<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/circularlinkedlist_test2.png" class></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p>示例3:<br><img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/circularlinkedlist_test3.png" class></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 [0, 10^4]</li>
<li>-10^5 &lt;= Node.val &lt;= 10^5</li>
<li>pos 为 -1 或者链表中的一个 有效索引。</li>
</ul>
<h3 id="解法1-set集合遍历链表法">3.1.1. 解法1: set集合遍历链表法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def hasCycle(self, head):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> not head:</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">        </span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        node = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (node):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> s:</span><br><span class="line">                <span class="built_in">return</span> True</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(node)</span><br><span class="line">            node = node.next</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> False</span><br></pre></td></tr></table></figure>
<h3 id="解法2-双指针法（龟兔赛跑）">3.1.2. 解法2: 双指针法（龟兔赛跑）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def hasCycle(self, head):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> not head:</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">        </span><br><span class="line">        fastnode = head</span><br><span class="line">        slownode = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fastnode):</span><br><span class="line">            <span class="keyword">if</span> fastnode.next and fastnode.next.next:</span><br><span class="line">                fastnode = fastnode.next.next</span><br><span class="line">                slownode = slownode.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">return</span> False</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> fastnode == slownode:</span><br><span class="line">                <span class="built_in">return</span> True</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> False</span><br></pre></td></tr></table></figure>
<h3 id="解法3-哈希表（字典）法">3.1.3. 解法3: 哈希表（字典）法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def hasCycle(self, head):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        m = dict()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> m.get(head):</span><br><span class="line">                <span class="built_in">return</span> True</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m[head] = 1</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="built_in">return</span> False</span><br></pre></td></tr></table></figure>
<h3 id="解法4-链表计数法（牛逼）">3.1.4. 解法4: 链表计数法（牛逼）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def hasCycle(self, head):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        count = 0</span><br><span class="line">        <span class="keyword">while</span> head and count &lt;= 10000:</span><br><span class="line">            count += 1</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="built_in">return</span> count&gt;10000</span><br></pre></td></tr></table></figure>
<h2 id="题目2：-环形链表2">3.2. 题目2： 环形链表2</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：<br>你是否可以使用 O(1) 空间解决此题？</p>
<p>示例1:</p>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/circularlinkedlist_test2.png" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p>示例3:</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/circularlinkedlist_test3.png" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围在范围 [0, 10^4] 内</li>
<li>-10^5 &lt;= Node.val &lt;= 10^5</li>
<li>pos 的值为 -1 或者链表中的一个有效索引</li>
</ul>
<h3 id="解法">3.2.1. 解法</h3><p>与<code>环形链表</code>这道题不同之处在于，前者只需要判断链表是否有环，现在需要判断环的入口在哪里。</p>
<p>参考:<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-jian-hua-gong-shi-jia-2/">代码随想录</a></p>
<p>Ps这个解释的数学推导无比清晰，视频也无比优秀</p>
<p>假设从头结点到环形入口结点的结数为<code>x</code>， 环形入口到fast/slow指针相遇的结点结数为y，从相遇结点到环形入欧结点结数为z，如图所示：</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/3be69ecc0e8948a5c0d74edfaed34d3eb92768ab781c1516bf00e618621eda66-142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" class>
<p>那么<strong>相遇时</strong>：</p>
<p>slow指针走过的结点数为：x + y</p>
<p>fast指针走过的结点数为：x + y + n(y+z), 其中n为fast指针在环内走了n圈才遇到slow指针，(y + z) 为一圈内结点的个数</p>
<p>fast指针一步走两个结点，slow指针一步走一个结点，所以fast指针走过的结点数 = 2 * slow指针走过的结点数</p>
<p><code>(x + y) * 2 = x + y + n (y + z)</code></p>
<p>两边消掉一个<code>（x+y）: x + y = n (y + z)</code></p>
<p>因为我们要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p>
<p>所以我们要求x ，将x单独放在左面：x = n (y + z) - y</p>
<p>在从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针</p>
<p>这个公式说明什么呢，</p>
<p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p>
<p>当 n为1的时候，公式就化解为 x = z</p>
<p>这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</p>
<p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p>
<p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p>
<p>那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p>
<p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p>
<p>在参考链接里的动画解释很好。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast and fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="comment"># 如果相遇</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                p = head</span><br><span class="line">                q = slow</span><br><span class="line">                <span class="keyword">while</span> p!=q:</span><br><span class="line">                    p = p.next</span><br><span class="line">                    q = q.next</span><br><span class="line">                <span class="comment">#你也可以return q</span></span><br><span class="line">                <span class="built_in">return</span> p</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> None</span><br></pre></td></tr></table></figure>
<h2 id="题目3-相交链表">3.3. 题目3: 相交链表</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160.相交链表</a></p>
<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表：</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/160_statement.png" class>
<p>示例1:</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/160_example_1.png" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/160_example_2.png" class>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>
<p>示例3:</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/160_example_3.png" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<h3 id="解法-1">3.3.1. 解法</h3><p>参考：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/jiao-ni-yong-lang-man-de-fang-shi-zhao-dao-liang-2/">派派</a></p>
<p>分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历，直至两个指针相遇。<br>最终两个指针分别走过的路径为：<br>指针A :a+c+b<br>指针B :b+c+a<br>明显 a+c+b = b+c+a,因而如果两个链表相交，则指针A和指针B必定在相交结点相遇。</p>
<img src="/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/lianbiao.png" class>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def getIntersectionNode(self, headA, headB):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> not headA or not headB:</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line"></span><br><span class="line">        nodeA, nodeB = headA, headB</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodeA != nodeB):</span><br><span class="line">            nodeA = nodeA.next <span class="keyword">if</span> nodeA <span class="keyword">else</span> headB</span><br><span class="line">            nodeB = nodeB.next <span class="keyword">if</span> nodeB <span class="keyword">else</span> headA</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">return</span> nodeA</span><br></pre></td></tr></table></figure>
<h2 id="题目4-删除链表的倒数第N个结点">3.4. 题目4: 删除链表的倒数第N个结点</h2><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第N个结点</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>
<p>示例1:</p>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p>示例2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure></p>
<h3 id="解法：">3.4.1. 解法：</h3><p>参考：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/chao-ke-ai-dong-hua-jiao-ni-ru-he-shan-chu-lian-bi/">派派</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line">class Solution(object):</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> not head:</span><br><span class="line">            <span class="built_in">return</span> head</span><br><span class="line">        </span><br><span class="line">        slownode = ListNode(0)</span><br><span class="line">        slownode.next = head</span><br><span class="line"></span><br><span class="line">        fastnode = slownode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            fastnode = fastnode.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> fastnode.next != None:</span><br><span class="line">            slownode = slownode.next</span><br><span class="line">            fastnode = fastnode.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> slownode.next == head:</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            slownode.next = slownode.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>转载:音频处理基本概念</title>
    <url>/2021/06/08/%E9%9F%B3%E9%A2%91%E5%89%8D%E5%A4%84%E7%90%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>转载自：<br><a href="https://www.jianshu.com/p/28dd7f1e58d0">音频基础知识</a></p>
<p><a href="https://blog.csdn.net/zhongshijunacm/article/details/104799137?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242">音频前处理基本概念</a></p>
<p><a href="https://my.oschina.net/u/4324171/blog/3556108">音频相关基本概念，音频处理及编解码基本框架和原理以及音、重采样、3A等音频处理(了解概念为主)</a></p>
<h3 id="音频基础知识">0.0.1. 音频基础知识</h3><p>声音信号通常是一种连续的波形来表示。波形的最大位移称为振幅A，反应音量。波形中两个连续波峰（或波谷）之间的距离称为周期T。周期的倒数即为频率f，以赫兹（Hz）为单位。频率反应了声音的音调。</p>
<p>声音可按频率分为三类：</p>
<p>次声波：频率低于20Hz。<br>音频；频率在20-20kHz。<br>超声：频率高于20kHz。</p>
<p>音频（Audio）指频率在20Hz-20kHz范围内的可听声音，是多媒体信息中的一种媒体类型 - 可听类媒体。</p>
<p>目前多媒体计算机中的音频主要由波形音频、CD音频和MIDE音乐3种形式。重点应该是波形音频。</p>
<ol>
<li>波形音频</li>
</ol>
<p>波形音频是由外部声音源通过数字化过程采集到多媒体计算机的所有声音形式。语音是波形声音中人说话的声音，具有内在的语言学、语音学的内涵。多媒体计算机可以利用特殊的方法分析、研究、抽取语音的相关特征，实现对不同语音的分辨、识别以及通过文字合成语音波形等。</p>
<ol>
<li>CD音频</li>
</ol>
<p>CD音频（CD-Audio）是存储在音乐CD光盘中的数字音频，可以通过CD-ROM驱动器读取并采集到多媒体计算机系统中，并以波形音频的相应形式存储和处理。</p>
<ol>
<li>MIDI音频</li>
</ol>
<p>MIDI音频（musical instrument digital interface），它将音乐符号化并保存在MIDI文件中，通过因为合成器产生相应的声音波形来还原播放。</p>
<p>音频是时间的函数，具有很强的前后相关性，所以实时性是音频处理的基本要求。</p>
<h3 id="音频的数字化">0.0.2. 音频的数字化</h3><p>计算机处理音频信号前，必须将模拟的声音信号数字化，产生数字音频。具体过程包括采样、量化与编码。</p>
<ol>
<li>采样与采样频率</li>
</ol>
<p>采样就是每间隔一段时间读取一次声音信号幅度，使声音信号在时间上被离散化。</p>
<p>采样频率就是将模拟声音波形数字化时，每秒钟抽取声波幅度样本的次数，其计算单位是kHz（千赫兹）。一般来说，采样频率越高，声音失真越小，用于存储的数字音频的数据量也越大。</p>
<p>乃奎斯特(Nyquist)采样理论：采样频率不应低于声音信号最高频率的两倍。这样就能把以数字表达的声音还原成原来的声音。例如：电话话音的信号频率约为 3.4 kHz，采样频率一般选用 8 kHz。</p>
<p>音频抽样率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz。</p>
<ol>
<li>量化与量化位数</li>
</ol>
<p>量化就是把采样得到的信号幅度转化为数字值，是声音信号在幅度上被离散化。量化位数（位深）是每个采样点能够表示的数据范围，常用的有8位、12位和16位。图示一个：</p>
<ol>
<li>声道</li>
</ol>
<p>反映音频数字化质量的另一个因素是声道个数。记录音频时，如果每次生成一个声波的数据，称为单声道；每次记录两个声波数据，称为双声道（立体声）；每次生成二个以上的声波数据，称为多声道（环绕立体声）。</p>
<ol>
<li>音频采样的数据量</li>
</ol>
<p>数字音频的采样数据量主要取决两方面的因素：</p>
<p>音质因素：采样频率、量化位数和声道数三个参数决定。<br>时间：采样时间长短。</p>
<h3 id="音频的编码">0.0.3. 音频的编码</h3><p>音频数据压缩编码的方法有多种，可分为无损压缩和有损压缩两大类。无损压缩主要包含各种熵编码；有损压缩则分为波形编码、参数编码、感知编码和混合编码。</p>
<p>波形编码：模拟音频数字化（抽样和量化）的过程中，根据人耳的听觉特性进行编码，并使编码后的音频信号与原始信号的波形尽可能匹配，实现数据压缩。</p>
<p>PCM (Pulse Code Modulation)、脉冲编码调制。<br>DPCM (Differential Pulse Code Modulation)。<br>APCM (Adaptive Pulse Code Modulation)。<br>ADPCM (Adaptive Differential Pulse Code Modulation)。<br>参数编码：把音频信号表示成模型的输出，利用特征的方法抽取必要的模型参数和激励信号的信息，且对这些信息编码，最后在输出端合成原始信号。</p>
<h3 id="音频采集">0.0.4. 音频采集</h3><p>音频采集播放流程：采集-前处理（回声消除、噪声抑制、音量调节、混响处理等）-编码-传输-解码-后处理-播放</p>
<p>采样率：原始PCM数据每秒采样次数</p>
<p>比特率：编码压缩后的码率，每秒音频的大小。（所以在编码效果好的情况下也会有高采样率对应相对低的比特率）</p>
<p>PCM(Pulse Code Modulation)，脉冲编码调制。人耳听到的是模拟信号，PCM是把声音从模拟信号转化为数字信号的技术。原理是用一个固定的频率对模拟信号进行采样，采样后的信号在波形上看就像一串连续的幅值不一的脉冲(脉搏似的短暂起伏的电冲                         击)，把这些脉冲的幅值按一定精度进行量化，这些量化后的数值被连续的输出、传输、处理或记录到存储介质中，所有这些组成了数字音频的产生过程(抽样、量化、编码三个过程)。</p>
<h3 id="音频前、后处理">0.0.5. 音频前、后处理</h3><p>ES: Echo Suppresion</p>
<p>EES: Enhanced Echo Suppresion</p>
<p>AEC: Acoustic Echo Cancellation 声学回声消除。在一般的VOIP软件或视频会议系统中，假设我们只有A和B两个人在通话，首先，A的声音传给B，B然后用喇叭放出来，而这时B的MIC呢则会采集到喇叭放出来的声音，然后传回给A，如果这个传输的过程中时延足够大，A就会听到一个和自己刚才说过的话一样的声音，这就是回声，声学回声消除器的作用就是在B端对B采集到的声音进行处理，把采集到声音包含的A的声音去掉再传给A，这样，A就不会听到自己说过的话了。就是说，在B端，接收到A说的话以后，要把这些话音数据传给回声消除器做参考，然后再传给声卡，声卡再放出来，这有一段延时，这时，B再采集，然后传给回声消除器，与那个参考数据比较，从采集到的数据中把频域和参考数据相同的部分消除掉。</p>
<p>NS: Noise Suppression 噪音抑制</p>
<p>NLP: Nonlinear Procession 去除残留的回声和背景噪声</p>
<p>NC: Noise Control</p>
<p>NR: Noise Reduction 降噪</p>
<p>CC: Clarity Control 清晰度控制</p>
<p>VAD: Voice Activity Detection 静音检测。静音检测（VAD）将检测被编码的音频数据是语音还是静音或背景噪声</p>
<p>DRC: Dynamic Range Control</p>
<p>AGC: Automatic Gain Control 自动增益控制。不同的设备，录音效果会有较大幅度的变动，自动增益控制（AGC）就是用来处理这种现象的。它提供了一种调整信号为参考音量的方法。这对VOIP（voice over IP）是非常有用的，因为它不需要再手动去调整麦克风增益。第二个好处是，将麦克风增益设置为保守(低)级别，可有效避免削波。</p>
<p>VBR: Variable Bit-Rate</p>
<p>CBR: Constant Bit-Rate</p>
<p>ABR: Average bit-rate</p>
<p>DTX: Discontinuous Transmission 非连续传输。非连续性传输（DTX）是静音检测（VAD）/变比特率（VBR）操作的额外选项，它能够在背景噪声固定时，完全的停止传输。</p>
<p>CNG: Comfort Noise Generator 舒适噪音生成。在非变比特率的情况下，检测非语音周期并对用足够的比特数重新生成的背景噪声进行编码。这个叫“舒适噪声生成（CNG）”。</p>
<p>音频加速器（Audio Accelerator）：即音频处理单元，有些厂家又叫APU(Audio Processing Unit)，好比计算机机的cpu，决定着声卡的音频处理能力。完全意义上的音频加速器由DSP(Digital Singnal Processor)和I/O控制器构成。I/O控制器即是输入/输出控制器，针对声卡的输入/输出进行控制。如果说一块声卡没有DSP，而只是一块I/O卡（比如绝大多数主板上自带的AC97声卡）那它所有的数据处理就只有交由CPU来完成。这将意味着增加CPU的负担，和低下的性能。</p>
<p>Codec：Codec一词由Coder和Decoder两个英文词组合而成，表示为多媒体数字信号解码器，专门负责模拟信号到数字信号的转换（ADC）以及数字信号到模拟信号的转换（DAC）工作。计算机声卡处理的信号全是数字信号，而声卡接收到的或者最终输出的信号大部份是模拟信号。从外办输入的信号，如CD、话筒等必须经过a/d转换后才能由声卡进行处理，然后又经过d/a转换后最终送入杨声器，被我们的耳朵所听到。因此Codec的质量直接决定着进出声卡的信号质量。</p>
<p>声卡的工作流程：MIDI、数字输入、模拟输入等信号—&gt;通各种接口输入—&gt;由晶震产生采样频率给Codec进行模/数转换—&gt;交给DSP+I/O器进行信号处理和分配—&gt;再由DAC或Codec进行数/模转换—&gt;最后由放大电路放大—&gt;输出至模拟输出接口</p>
<p>AC97（Audio Codec 97）：一种规范。</p>
<p>Amplitude（增益/衰减）:对于一个音频信号进行放大（正增益），或者衰减（负增益），是DSP一个最基本的功能。而这些操作实质上就是对电流脉冲的增强和减小。在电路中，可以通过电阻实现这项功能。</p>
<p>Filter（滤波器）：滤波器也是DSP的基础功能，所谓滤波器，就是过滤掉符合特定条件的声音，比如常见的频率滤波器。常见的频率滤波器包括低通滤波器（Low pass filter），高通滤波器(High pass filter)，带通滤波器(band pass filter)等。他们都是用来过滤掉特定的频率，比如低通滤波器。<br>低通滤波器，顾名思义就是让低频信号通过，而其他信号则被过滤掉，一般音响系统中习惯使用低通滤波器分离出单独的超重低音通道来，从而组成X.1系统。<br>高通滤波器，就是允许高频信号通过，而将其他信号拒之门外。<br>带通滤波器比较有意思，它会让需要的频段顺利通过，而阻止不需要的频段。<br>陷波滤波器（band reject filter）像一个倒置的带通滤波器，它会阻止需要的频段，而让不需要的频段顺利通过。<br>滤波器对于DSP的重要意义在于能够分离出不同的频段，从而进行相关的操作。</p>
<p>震荡器：是一个产生波形的设备，它能够发出规则的或者循环的正弦波、方波、三角波和锯齿波。而这些波形拥有不同的用途，比如正弦波可以当作激励来使用。因此在音频数据中添加不同种类的波，就可以制造出各种绚丽的效果来，比如镶边等。</p>
<p>Delay（延时）：所谓的延时，就是沿着时间轴移动音频数据，从而使得声音听起来要延后一些，在DSP中实现这项功能也是非常简单的。</p>
<p>ADSR（音色包络）：震荡器产生波形后，如果不加以控制，则这些波形将会一直震荡下去，这当然不是我们需要的。因此，我们需要给波形加上起止的控制，这就是ADSR包络了。A代表Attack，指的是声音从开始发声到最大振幅的过程；D代表Decay，指的是声音从最大振幅开始衰减的一段；S指的是Sustain，指的是声音衰减到一定位置维持住的过程；R代表Release，指的是停止发声后到声音消失的过程。有了ADSR，我们就能够控制一个波形的起止位置，从而实现我们想要的效果。</p>
<p>Gate门限：Gate应该算是计算机算法中的逻辑术语了。所谓门，就是按照一定的条件处理数据，符合条件的在门的一边，不符合条件的在门的另一边。门在DSP中主要用作按照条件对音频数据进行分离。</p>
<p>EQ：被称为均衡(Equalizer)，是DSP必备的高档功能之一。EQ基本作用是通过对声音某一个或多个频段进行增益或衰减，达到调整音色的目的。当然，EQ还有一个显著的功能，降噪。因此对于声音的整体音色有着很大的影响。<br>EQ通过将声音中各频率的组成泛音等级加以修改，专为某一类音乐进行优化，增强人们的感觉。常见包括：正常、摇滚、流行、舞曲、古典、柔和、爵士、金属、重低音和自定义。<br>EQ通常包括如下参数：F(requency)，频率――这是用于设定你要进行调整的频率点用的参数；G(ain)，增益――用于调整在你设定好的F值上进行增益或衰减的参数；Q(uantize)――用于设定你要进行增益或衰减的频段“宽度”。要注意的一点是：当你设定的Q值越小的时候，你所处理的频段就越宽，而当你设定的Q值越大的时候，你所处理的频段就越窄。<br>从控制的方式来说，EQ有图形EQ和参量EQ两种。</p>
<p>SRC：就是Sample Rate Convertor采样频率转换器，intel AC’97规范约定了声卡需要经过这样一个处理过程，即将所有信号重新转换成一个统一的采样率输出。SRC如果进行了非整数倍的转换的话，比如44100-&gt;48000，会有较大的噪声或者谐波出现，这些噪声因转换器的质量高低、算法好坏而定，不优秀的算法会比较严重的影响听感。既然SRC是一个可能破坏音质的过程，为什么会有这么一个产物呢？前面就说过，AC’97是为了节省成本而订，SRC的结果可以为声卡省下一颗Crystal。SRC一般都通过软件运算转换，这样受驱动版本的影响非常之大，例如Live!系列，SRC品质最好的是Windows Server2003 自带的驱动，也有使用硬件SRC的，例如：CS4630音频加速器。硬件SRC的品质往往大大优于软件的SRC，SRC品质的好坏的重要性甚至比Codec的档次更重要。</p>
<p>Crystal：中文名就是石英晶体振荡器或者简称晶振。常见的声卡都支持44.1kHz和48kHz的信号输入。</p>
<h3 id="混音技术介绍">0.0.6. 混音技术介绍</h3><p>混音，顾名思义，就是把两路或者多路音频流混合在一起，形成一路音频流。而混流，则是指音视频流的混合，也就是视频画面和声音的对齐，也称混流。</p>
<p>并非任何两路音频流都可以直接混合。两路音视频流，必须符合以下条件才能混合：</p>
<ul>
<li>格式相同，要解压成 PCM 格式。</li>
<li>采样率相同，要转换成相同的采样率。主流采样率包括：16k Hz、32k Hz、44.1k Hz 和 48k Hz。</li>
<li>帧长相同，帧长由编码格式决定，PCM 没有帧长的概念，开发者自行决定帧长。为了和主流音频编码格式的帧长保持一致，推荐采用 20ms 为帧长。</li>
<li>位深（Bit-Depth）或采样格式 (Sample Format) 相同，承载每个采样点数据的 bit 数目要相同。</li>
<li>声道数相同，必须同样是单声道或者双声道 (立体声)。这样，把格式、采样率、帧长、位深和声道数对齐了以后，两个音频流就可以混合了。</li>
</ul>
<p>在混音之前，还需要做回声消除、噪音抑制和静音检测等处理。回声消除和噪音抑制属于语音前处理范畴的工作。在编码之前，采集、语音前处理、混音之前的处理、混音和混音之后的处理应该按顺序进行。静音抑制（VAD，Voice Activity Detect）可做可不做。对于终端混音，是要把采集到的主播声音和从音频文件中读到的伴奏声音混合。如果主播停顿一段时间不发出声音，通过 VAD 检测到了，那么这段时间不混音，直接采用伴奏音乐的数据就好了。然而，为了简单起见，也可以不做 VAD。主播不发声音的期间，继续做混音也可以（主播的声音为零振幅）</p>
<h3 id="音频重采样">0.0.7. 音频重采样</h3><p>音频系统中可能存在多个音轨，而每个音轨的原始采样率可能是不一致的。比如在播放音乐的过程中，来了一个提示音，就需要把音乐和提示音都混合到codec输出，音乐的原始采样率和提示音的原始采样率可能是不一致的。问题来了，如果codec的采样率设置为音乐的原始采样率的话，那么提示音就会失真。因此最简单见效的解决方法是：codec的采样率固定一个值（44.1KHz/48KHz），所有音轨都重采样到这个采样率，然后才送到codec，保证所有音轨听起来都不失真。</p>
<p>重采样即是将音频进行重新采样得到新的采样率的音频。</p>
<h3 id="音频3A处理">0.0.8. 音频3A处理</h3><p>音频3A处理在不同的应用场景三者的处理顺序也不同，如在WebRTC中音频数据回依次经过AEC和NS（noise suppression） 或者 NS 与AECM（AECM 是WebRTC专门为移动端打造的算法，计算量低，而AEC 是为PC打造的）。而在AEC(回声消除算法)，为什么需要这个算法呢？当一个设备在播放声音经过空间中的多次反射会被麦克风再次捕捉并采集到系统当中，这时音频的输入既有空间反射的回声也有本端说话声，如果缺少此模块就意味着通话中说话人一直可以听到自己的声音回来，这是非常差的一种体验，这当然是需要我们避免的。这里AEC的作用就是通过播放的参考信号跟踪出回声并从采集信号中把回声消除掉，随后再经过降噪处理去除噪声。而其中的AECM是在NS模块之后通过获取clean与noise数据进行分析，AEC则是NS模块之前直接获取noise数据进行分析。</p>
<p>音频数据完成AEC与NS的处理后会进行AGC处理，其包括AAGC（模拟域的自动增益控制）与DAGC（数字域的自动增益控制）。其中AAGC的主要作用是通过系统的采集音量设置接口调整输入信号（大多用于PC端，移动端一般没有输入音量的系统接口），如借助Windows上的的API调整采集音量等参数。AAGC可为输入的音频数据带来明显的质量优化，如提高信噪比，避免输入信号溢出等。但由于我们服务的跨平台要求，我们需要构建一个面向多平台设备的框架，在不同的输入平台和设备都会有不同的输入音量，DAGC可以根据对输入信号的跟踪，尽量的调整信号到达期望大小(幅值或能量)，从而避免不同设备采集带来的音量差异过大。完成AGC处理的音频数据，即可进入Audio Encode进行编码操作。</p>
]]></content>
      <categories>
        <category>信号处理</category>
      </categories>
  </entry>
</search>
